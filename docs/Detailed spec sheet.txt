```markdown ## File System * Frontend/ * src/ * components/ * FocusTimer/ * FocusTimer.tsx // Main orchestrator for timer logic and UI * TimerDisplay.tsx // Visual representation of time (circular/digital) * TimerControls.tsx // Buttons: Start, Pause, Give Up * SessionSummaryModal.tsx // Modal displayed after session (covered by its own feature) * GoalReward/ * GoalSetter.tsx * XPProgressBar.tsx * DestinationReachedModal.tsx * MusicPlayer/ * MusicPlayer.tsx * TrackList.tsx * PlayerControls.tsx * Starfield/ * StarfieldCanvas.tsx // Renders the animated background * PostureTracker/ * PostureTracker.tsx * CalibrationGuide.tsx * FeedbackBar.tsx * CameraView.tsx * Notepad/ * NotepadPanel.tsx // Container for Notepad and Action List tabs * MarkdownEditor.tsx * ActionList.tsx * AIBuddy/ * AIBuddyChat.tsx * ChatMessage.tsx * FocusBooster/ * FocusBooster.tsx * BoosterIcon.tsx * shared/ // Common UI elements * Modal.tsx * Button.tsx * Slider.tsx * Input.tsx * Accordion.tsx * Icon.tsx * Spinner.tsx * hooks/ // Reusable logic * useTimer.ts // Core timer logic hook * useAudio.ts // Hook for managing HTMLAudioElement instances * useMediaPipe.ts // Hook for abstracting MediaPipe interactions * useLLM.ts // Hook for Transformers.js interaction * usePersistentState.ts // Custom hook for easy Zustand-IndexedDB sync * lib/ // Utility functions * mediaPipeUtils.ts // Helper functions for MediaPipe data processing * markdownParser.ts // Simple Markdown to HTML * sfxManager.ts // Manages loading and playing SFX * llmManager.ts // Manages local LLM loading and inference * timeUtils.ts // Date/time formatting and calculations * services/ // Abstractions for external/browser features * persistenceService.ts // Wrapper around localforage/idb-keyval for IndexedDB * workers/ // Web Workers * posture.worker.ts // Runs MediaPipe Pose inference * llm.worker.ts // Runs Transformers.js model inference (optional, based on performance) * store/ // Zustand global state management * index.ts // Main store setup * slices/ // Individual state slices * appSlice.ts // Global app settings, PWA status, onboarding * timerSlice.ts // State for Focus Timer, session data * goalSlice.ts // State for goals, rewards, XP * musicSlice.ts // State for Music Player * starfieldSlice.ts // State for Starfield Background settings * postureSlice.ts // State for Posture Tracker * editorSlice.ts // State for Notepad & Action List * aiBuddySlice.ts // State for AI Buddy Chat * focusBoosterSlice.ts // State for Focus Booster * assets/ // Static assets * music/ * ambient_space_1/ * track1.mp3 * ... (4-6 more tracks) * focus_flow_mix/ * track1.mp3 * ... (4-6 more tracks) * sfx/ * start_session.mp3 * pause_session.mp3 * session_done.mp3 * task_check.mp3 * action_cancel.mp3 * distraction_logged.mp3 * streak_achieved.mp3 * whoosh_start.mp3 * ambient_booster_bed.mp3 * booster_complete.mp3 * images/ * hero_goal_1.png * ... (4-9 more thematic hero images) * static_starfield_fallback.jpg * app_icons/ (for PWA manifest) * icon-72x72.png * icon-96x96.png * ... * fonts/ * (any custom fonts) * styles/ // Global styles, variables * main.css * variables.css * App.tsx // Root React component, layout * main.tsx // Entry point, renders App * index.html * vite-env.d.ts * tsconfig.json * vite.config.ts // Vite build configuration, including PWA plugin setup * service-worker.ts // Custom service worker logic (if extending vite-plugin-pwa) * manifest.webmanifest // PWA manifest template (values injected by vite-plugin-pwa) * Backend/ * N/A (MVP is offline-first PWA; no server-side backend components) ## Feature Specifications **Feature 1: Focus Timer & Session Control** **Goal** To provide a reliable and user-friendly timer for tracking deep work sessions (Pomodoro-like or infinite duration), managing session states (start, pause, end/give-up), and serving as the core driver for time-based events and data collection within the application. **API relationships** * **Internal Services:** * `Zustand store (timerSlice)`: Reads and writes all timer-related state (duration, remaining time, status, session ID, start time, distraction count). * `Zustand store (starfieldSlice)`: Updates starfield animation state (e.g., "thrust" on session start). * `Zustand store (goalSlice)`: On session completion, updates accumulated focus time. * `SFXManager`: Triggers SFX for start, pause, and session completion. * `PersistenceService (IndexedDB)`: Saves active session state (timer value, start time, session ID, type - Pomodoro/Infinite) to allow recovery after page refresh/close. * **Browser APIs:** * `Date.now()`: For accurate time tracking, resilient to tab throttling. * `requestAnimationFrame` or `setTimeout/setInterval`: For updating the visual display of the timer. `requestAnimationFrame` is preferred for UI updates if complex, but `Date.now()` checks are the source of truth for time calculation. * (Potentially `Web Workers` if extreme background timer accuracy is needed, but current guidance is `Date.now()` checks should suffice). **Architecture overview** * **Diagram Reference:** The Focus Timer UI Components interact with the `timerSlice` in Zustand. The `timerSlice` communicates with `PersistenceService` for saving/loading session state. It also influences the `starfieldSlice` and `goalSlice`. `SFXManager` is triggered by state changes in `timerSlice`. * **Tech-stack Justification:** * React components for UI. * Zustand for global state management: simple, performant, and suitable for managing shared timer state across components. * `Date.now()` for time calculation: robust and standard for web timers. * IndexedDB (via `PersistenceService`): for session persistence, crucial for an offline-first app. * **Deployment:** Deployed as part of the static PWA bundle. Timer logic is entirely client-side. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `activeSession` * **KeyPath:** `id` (e.g., a constant string like `"current_focus_session"`, as there's only one active session at a time). * **Structure Example:** ```json { "id": "current_focus_session", "sessionId": "uuid-v4-string", // Unique ID for this specific session instance "startTime": 1678886400000, // Timestamp of session start "configuredDuration": 1500, // Seconds (e.g., 25 * 60 for Pomodoro) or 0 for infinite "elapsedTimeWhenPaused": 300, // Seconds elapsed if timer was paused, otherwise 0 "status": "paused", // "running" | "paused" | "idle" "isInfinite": false, // boolean "distractionCount": 0 } ``` * If `status` is "idle", the record might be deleted or nulled out, except for `distractionCount` which might be reset. * **Indexes:** None needed for `activeSession` as it's always fetched by its static key. * **Migrations:** If the `activeSession` schema changes, `PersistenceService` would need a versioning mechanism. On app load, it checks the stored version and applies transformations if necessary. For MVP, direct overwrite or clear-and-recreate is simpler if schema is stable. **API design (Zustand `timerSlice` actions & selectors)** * **Actions (examples):** * `startSession(durationInSeconds: number, isInfinite: boolean)`: * Request: `{ durationInSeconds: 1500, isInfinite: false }` * Effect: Sets status to "running", records `startTime`, `configuredDuration`, `isInfinite`, generates `sessionId`, resets `distractionCount`. Persists to IndexedDB. Triggers "thrust" animation. Plays start SFX. * `pauseSession()`: * Request: (none) * Effect: Sets status to "paused", records `elapsedTimeWhenPaused`. Persists. Plays pause SFX. * `resumeSession()`: * Request: (none) * Effect: Sets status to "running", recalculates `startTime` effectively as `Date.now() - elapsedTimeWhenPaused`. Persists. Plays start SFX (or resume SFX). * `giveUpSession()`: * Request: (none) * Effect: Calculates actual duration. Triggers session summary modal. Clears active session state. Plays "give up" SFX. Updates goal progress with actual duration. * `completeSession()`: * Request: (none) * Effect: Similar to `giveUpSession` but specifically for timed sessions ending naturally. Triggers session summary. Plays "done" SFX. Updates goal progress. * `incrementDistraction()`: * Request: (none) * Effect: Increments `distractionCount`. Persists. Plays distraction SFX. * `loadSessionFromPersistence()`: * Request: (none) * Effect: Attempts to load `activeSession` from IndexedDB. If found and valid (e.g., not from a very old app version), hydrates the timer state. * **Selectors (examples):** * `selectCurrentTimeLeft(): number` (seconds) * `selectTimerStatus(): 'running' | 'paused' | 'idle' | 'finished'` * `selectIsInfinite(): boolean` * `selectDistractionCount(): number` * `selectSessionProgress(): number` (0.0 to 1.0) * **Auth:** N/A. * **Errors:** * Persistence errors (e.g., IndexedDB full/unavailable) should be logged. Timer should still function in memory. * Invalid state transitions (e.g., trying to pause an idle timer) should be prevented by UI logic or handled silently in the store. * **Rate-limit:** N/A. **Frontend structure** * **Component Hierarchy:** * `App.tsx` (contains layout where FocusTimer is placed) * `FocusTimer.tsx` (orchestrator, holds primary state or connects to Zustand `timerSlice`) * `TimerDisplay.tsx` (props: `timeLeft`, `totalDuration`, `isInfinite`, `status`) * `TimerControls.tsx` (props: `status`, callbacks: `onStart`, `onPause`, `onResume`, `onGiveUp`) * (SessionSummaryModal is shown conditionally, managed by `timerSlice` state) * **State Management (Zustand `timerSlice`):** * `status: 'idle' | 'running' | 'paused' | 'finished'` * `startTime: number | null` (timestamp) * `configuredDuration: number` (seconds, 0 for infinite) * `elapsedSeconds: number` (derived or stored on pause) * `isInfinite: boolean` * `sessionId: string | null` * `distractionCount: number` * `showSummaryModal: boolean` * `intervalId: number | null` (for `setInterval`/`setTimeout` if used) * **Navigation:** N/A (controls are part of main UI). Session Summary is a modal. **CRUD operations** * **Create:** User initiates a new session (Start button). * **Read:** Timer display shows current time. Session summary displays session data. * **Update:** * Timer counts down / up. * User pauses/resumes. * Distraction count increments. * **Delete:** Session effectively "deleted" when completed or given up (state reset to idle). Persistent `activeSession` record is cleared. * **Validation:** * Input for Pomodoro duration (if user-configurable post-MVP) must be a positive number. MVP uses fixed (e.g., 25 min) or infinite. * **Pagination:** N/A. * **Soft vs. Hard Delete:** N/A for active session. Completed session data is passed to summary/goal, not stored as a "timer session log" in this feature's scope. **UX flow** 1. **Initial State:** Timer displays "00:00" or prompts to start. "Start" button active. "Pause", "Give Up" disabled. 2. **User Clicks "Start" (e.g., Pomodoro 25 min):** * UI: Timer starts counting down from "25:00". "Start" becomes "Pause". "Give Up" enabled. * SFX: `start_session.mp3` plays. * Animation: Starfield "thrust" animation plays. 3. **User Clicks "Pause":** * UI: Timer freezes. "Pause" becomes "Resume". * SFX: `pause_session.mp3` plays. 4. **User Clicks "Resume":** * UI: Timer continues. "Resume" becomes "Pause". * SFX: `start_session.mp3` (or a distinct resume SFX). 5. **Timer Completes (Pomodoro):** * UI: Timer shows "00:00". Controls might disable/reset. * SFX: `session_done.mp3` plays. * Modal: Session Summary modal appears. 6. **User Clicks "Give Up":** * UI: Timer stops. Controls might disable/reset. * SFX: (distinct `session_give_up.mp3` or `action_cancel.mp3`) * Modal: Session Summary modal appears. 7. **User Clicks "Distracted" button (external to timer controls but updates timer state):** * UI: Brief visual feedback (e.g., "+1 Distraction" text flash). Counter (if visible) updates. * SFX: `distraction_logged.mp3` plays. * Timer: Continues running. `distractionCount` in `timerSlice` increments. * **Loading States:** Minimal. Button clicks should be near-instant. * **Error States:** If IndexedDB fails to save, a subtle, non-blocking notification might appear ("Could not save session progress, functionality might be limited on refresh"). Timer should still work in memory. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** N/A for timer values themselves. Any user-inputted descriptions tied to sessions (post-MVP) would need sanitization. * **OWASP Protections:** N/A directly for timer logic. **Testing** * **Unit Tests (Vitest):** * `useTimer` hook logic: start, pause, resume, reset, time calculation, infinite mode. * `timerSlice` reducers/actions: state transitions, persistence calls. * Time formatting utilities. * **Integration Tests:** * `FocusTimer` component interaction with `timerSlice` and `PersistenceService`. * Timer events correctly triggering SFX via `SFXManager`. * Timer completion correctly updating `goalSlice`. * Session state correctly saved to and loaded from IndexedDB on refresh. * **E2E Tests (Playwright/Cypress):** * User starts a Pomodoro session, pauses, resumes, lets it complete. Verify UI, SFX (mocked), and Session Summary appearance. * User starts an infinite session, logs distractions, gives up. Verify UI and Session Summary. * Reload page during an active session; verify timer state is restored. * **Performance Tests:** * Ensure timer updates (visual) are smooth and don't cause jank, especially if using `requestAnimationFrame` for complex displays. Target 60 FPS for UI updates. * Timer accuracy should be within user-perceptible limits (e.g., +/- 1 second over a 25-minute session is fine). Date.now() ensures this. **Data management** * **Caching:** * Active session state is "cached" in IndexedDB to survive refreshes. * Component logic and UI assets are cached by the PWA Service Worker. * **Lifecycle:** * **Creation:** Session starts, `activeSession` record created/updated in IndexedDB. * **Update:** Timer progresses, pause/resume events update `elapsedTimeWhenPaused` and `status` in IndexedDB. Distractions update `distractionCount`. * **Deletion:** `activeSession` record cleared from IndexedDB when session ends (completed/given up) or reset. Data from the session (duration, distractions) is passed to other features (Session Summary, Goal/XP) but not stored long-term *by this feature*. * **Real-time Needs:** Timer display needs real-time updates (approx. every second). Visual feedback for state changes. **Logging & error handling** * **Structured Logs (Console for Dev, potentially remote logging service post-MVP):** * `INFO: Session started (ID: ${sessionId}, Type: ${isInfinite ? 'Infinite' : 'Pomodoro'}, Duration: ${configuredDuration})` * `INFO: Session paused (ID: ${sessionId}, Elapsed: ${elapsedSeconds})` * `INFO: Session resumed (ID: ${sessionId})` * `INFO: Session completed (ID: ${sessionId}, ActualDuration: ${actualDuration}, Distractions: ${distractionCount})` * `INFO: Session given up (ID: ${sessionId}, ActualDuration: ${actualDuration}, Distractions: ${distractionCount})` * `WARN: Failed to save session state to IndexedDB: ${error.message}` * `WARN: Failed to load session state from IndexedDB: ${error.message}` * `INFO: Loaded active session from IndexedDB.` * **Alerts (Developer-facing):** If a remote logging service is used, critical errors (e.g., consistent IndexedDB failure) could trigger alerts. * **Recovery:** * **Page Refresh:** `loadSessionFromPersistence()` action in `timerSlice` attempts to restore state. If `activeSession` data is corrupted or missing, timer starts fresh in 'idle' state. * **Browser Crash:** Same as page refresh. * **IndexedDB Failure:** Timer continues in-memory. User is warned that progress won't save. **Detailed requirements** (from input) * One-click Start / Pause / Give Up controls. * Visual timer display (e.g., circular progress, digital countdown). (Quadratic timer with dynamic color feedback TBD post-design review; MVP is linear). * Automatic session-summary modal on finish or "Give Up". * Starfield “thrust” animation tied to timer state. * Accurate timer (sufficient for user perception) unaffected by tab switching (using `Date.now()` checks). * Must survive page refresh via `localStorage` or `IndexedDB` persistence for active session state (timer value, start time, session ID). (Decision: IndexedDB via `PersistenceService`). * Distraction button increments counter, plays SFX, gives visual feedback, impacts streak (logic for streak handled by Session Summary/Goal features, but count is from here). Does NOT pause timer. * MVP Pomodoro handling: Manual start/end of focus blocks. No automated break timer in MVP v1. **Implementation guide** * **Pseudocode (`useTimer` hook / `timerSlice` core logic):** ```typescript // Zustand timerSlice state state = { status: 'idle', // 'running', 'paused', 'finished' startTime: null, // timestamp configuredDuration: 0, // seconds elapsedSecondsWhenPaused: 0, // seconds isInfinite: false, sessionId: null, distractionCount: 0, _intervalId: null, // To clear interval/timeout for UI updates _uiDisplayTime: "00:00" // String for UI, updated by interval } // Actions function startSession(configDuration, infinite): state.status = 'running' state.startTime = Date.now() state.configuredDuration = infinite ? 0 : configDuration state.elapsedSecondsWhenPaused = 0 state.isInfinite = infinite state.sessionId = generateUUID() state.distractionCount = 0 persistStateToIndexedDB(state) triggerStarfieldThrust() playSFX('start_session') startUiUpdateInterval() function pauseSession(): if state.status is not 'running': return clearUiUpdateInterval(state._intervalId) state.elapsedSecondsWhenPaused = (Date.now() - state.startTime) / 1000 state.status = 'paused' persistStateToIndexedDB(state) playSFX('pause_session') function resumeSession(): if state.status is not 'paused': return state.startTime = Date.now() - (state.elapsedSecondsWhenPaused * 1000) state.status = 'running' persistStateToIndexedDB(state) playSFX('start_session') // or 'resume_session' startUiUpdateInterval() function endSession(type: 'completed' | 'given_up'): clearUiUpdateInterval(state._intervalId) actualDuration = 0 if state.startTime: actualDuration = ((Date.now() - state.startTime) / 1000) + state.elapsedSecondsWhenPaused if not state.isInfinite and actualDuration > state.configuredDuration: actualDuration = state.configuredDuration // Cap at configured duration if timed // Store session data for summary const sessionSummaryData = { duration: actualDuration, distractions: state.distractionCount, // ... other relevant data } // Reset timer state state.status = 'finished' // or 'idle' after summary shown state.startTime = null // ... reset other relevant fields clearActiveSessionFromIndexedDB() if type is 'completed': playSFX('session_done') else: // 'given_up' playSFX('action_cancel') // or specific give_up sfx updateGoalProgress(actualDuration) // Action from goalSlice showSessionSummaryModal(sessionSummaryData) // Action from appSlice or timerSlice function incrementDistraction(): state.distractionCount++ persistStateToIndexedDB(state) // Persist updated distraction count playSFX('distraction_logged') // UI feedback for distraction logged function loadPersistedSession(): persistedData = loadStateFromIndexedDB() if persistedData and persistedData.status is 'running' or persistedData.status is 'paused': state = { ...state, ...persistedData } if state.status is 'running': // Adjust startTime based on time passed since persistence // This needs careful calculation if tab was inactive for long // Safest: if status was 'running', treat as if paused then resumed or recalculate elapsed // Simpler: Assume it was paused, or prompt user. // For MVP: if status was 'running', on load, if significant time passed, could set to 'paused' at persisted elapsed time. // Or, if startTime and elapsedSecondsWhenPaused are stored, can reconstruct. // Best approach: if session was running, recalculate effective startTime based on current time and total time that should have elapsed. // Example: targetEndTime = persistedData.startTime + persistedData.configuredDuration * 1000 // remainingTime = targetEndTime - Date.now() // if remainingTime <=0, session effectively ended. // if infinite, startTime is adjusted, elapsed is Date.now() - startTime. // if paused, it's simpler, just restore elapsedSecondsWhenPaused. // Let's refine persistence: store raw `startTime` and `pauseTime` (timestamp when paused) // `activeSession` record in DB: // { id, sessionId, initialStartTime, configuredDuration, status: 'running'|'paused', pauseTime: null | timestamp, isInfinite, distractionCount } // On load, if status === 'running': // elapsed = (Date.now() - initialStartTime) / 1000 // if status === 'paused': // elapsed = (pauseTime - initialStartTime) / 1000 // state.elapsedSecondsWhenPaused = elapsed // state.startTime = initialStartTime // This allows accurate reconstruction. if state.status is 'running' or (state.status is 'paused' and state.elapsedSecondsWhenPaused < state.configuredDuration or state.isInfinite): startUiUpdateInterval() // Start UI updates if session is still active function startUiUpdateInterval(): clearUiUpdateInterval(state._intervalId) state._intervalId = setInterval(() => { if state.status is not 'running': clearUiUpdateInterval(state._intervalId) return elapsed = (Date.now() - state.startTime) / 1000 if state.isInfinite: state._uiDisplayTime = formatTime(elapsed) else: remaining = state.configuredDuration - elapsed if remaining <= 0: state._uiDisplayTime = formatTime(0) endSession('completed') else: state._uiDisplayTime = formatTime(remaining) }, 1000) // Update UI every second ``` * **Data Flow Steps:** 1. User interacts with `TimerControls.tsx`. 2. Callback in `FocusTimer.tsx` calls action in `timerSlice` (e.g., `startSession`). 3. `timerSlice` updates its state, calls `PersistenceService` to save to IndexedDB, triggers SFX, updates `starfieldSlice`. 4. React components subscribed to `timerSlice` (like `TimerDisplay.tsx`) re-render with new data. 5. On session end, `timerSlice` calls action in `goalSlice` to update accumulated time and triggers display of `SessionSummaryModal.tsx`. 6. On app load, `timerSlice` `loadSessionFromPersistence()` action is dispatched to restore state. * **Key Edge Cases:** * **Tab Inactivity/Throttling:** `Date.now()` usage for calculations makes it resilient. UI updates might lag but timekeeping is correct. * **Browser Clock Changes:** `Date.now()` relies on system clock. If user changes system time mid-session, timer will be affected. This is an accepted limitation for client-side timers. * **Rapid Clicks:** Debounce or disable buttons during state transitions to prevent multiple inconsistent actions. * **IndexedDB Failure:** Log error, notify user subtly, timer continues in-memory without persistence for that session. * **Very short sessions:** Ensure calculations and state updates are correct even if a session is started and immediately given up. * **Infinite timer "completion":** Infinite timers don't "complete" but are "given up." Ensure this path is handled correctly. --- **Feature 2: Goal / Reward & XP Progress** **Goal** To allow users to define a total focus time goal for a period, specify an optional reward, and visually track their progress towards this goal via an XP bar, culminating in a "Destination Reached" acknowledgment. **API relationships** * **Internal Services:** * `Zustand store (goalSlice)`: Manages goal state (total time, reward text, accumulated time). * `Zustand store (timerSlice)`: Reads `accumulatedFocusTime` from `goalSlice` after a session completes to check if the goal is met. `timerSlice.completeSession/giveUpSession` action calls an action in `goalSlice` to add focus time. * `PersistenceService (IndexedDB)`: Saves and loads goal state. * **Browser APIs:** N/A directly. **Architecture overview** * **Diagram Reference:** `GoalSetter` UI component interacts with `goalSlice`. `XPProgressBar` displays data from `goalSlice`. `timerSlice` updates `goalSlice` on session completion. `DestinationReachedModal` is triggered by `goalSlice` when goal is met. `goalSlice` uses `PersistenceService`. * **Tech-stack Justification:** * React components for UI. * Zustand for state management. * IndexedDB for persistence. * **Deployment:** Part of the static PWA bundle. All logic is client-side. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `userGoal` * **KeyPath:** `id` (e.g., a constant string like `"current_user_goal"`). * **Structure Example:** ```json { "id": "current_user_goal", "targetFocusTime": 7200, // seconds (e.g., 2 hours) "rewardText": "Buy that new book", // optional string "accumulatedFocusTime": 1800, // seconds towards current target "goalSetTimestamp": 1678886400000 // Timestamp when this goal was set or last modified } ``` If no goal is set, this record might be absent or have `targetFocusTime: 0`. * **Indexes:** None needed, fetched by static key. * **Migrations:** Handle schema changes in `PersistenceService`. For MVP, direct overwrite. **API design (Zustand `goalSlice` actions & selectors)** * **Actions (examples):** * `setGoal(targetTimeInSeconds: number, rewardText?: string)`: * Request: `{ targetTimeInSeconds: 7200, rewardText: "Ice cream" }` * Effect: Updates `targetFocusTime`, `rewardText`, resets `accumulatedFocusTime` to 0 if it's a new goal (or preserves if editing existing an non-completed goal - clarify this logic: specs say "Clear/edit actions... with confirmation." Typically new goal means new progress.). Sets `goalSetTimestamp`. Persists. * *Clarification*: Setting a new goal (even if editing) should reset `accumulatedFocusTime` to 0 for that new goal. If the intention is to *adjust* an existing goal without losing progress, that's a different action (e.g., `adjustGoalTarget`). For MVP, `setGoal` implies starting fresh for that target. * `addFocusTime(seconds: number)`: * Request: `{ seconds: 1500 }` * Effect: Increments `accumulatedFocusTime`. Checks if `accumulatedFocusTime >= targetFocusTime`. If so, sets `goalReached: true` (transient state to trigger modal). Persists. * `clearGoal()`: * Request: (none) * Effect: Resets `targetFocusTime`, `rewardText`, `accumulatedFocusTime` to initial/empty states. Persists. Dismisses "Destination Reached" modal if visible. * `markGoalAsCompletedAndReset()`: (Called after "Destination Reached" modal is acknowledged by user) * Effect: Clears the goal, similar to `clearGoal()`, allowing user to set a new one. * `loadGoalFromPersistence()`: * Effect: Loads `userGoal` from IndexedDB. * **Selectors (examples):** * `selectTargetFocusTime(): number` * `selectRewardText(): string | undefined` * `selectAccumulatedFocusTime(): number` * `selectGoalProgressPercent(): number` (0-100) * `selectIsGoalMet(): boolean` * **Auth:** N/A. * **Errors:** Persistence errors logged. UI should function with in-memory state. * **Rate-limit:** N/A. **Frontend structure** * **Component Hierarchy:** * `GoalSetter.tsx` (Accordion with inputs for time and reward text, Save/Clear buttons) * `XPProgressBar.tsx` (Visual bar, ship icon, tooltip with details) * `DestinationReachedModal.tsx` (Displays hero image, stats, reward; shown when `goalSlice.isGoalMet` is true) * **State Management (Zustand `goalSlice`):** * `targetFocusTime: number` (seconds) * `rewardText: string | null` * `accumulatedFocusTime: number` (seconds) * `isGoalSet: boolean` (derived: `targetFocusTime > 0`) * `showDestinationReachedModal: boolean` (controls modal visibility) * **Navigation:** `DestinationReachedModal` is a modal. `GoalSetter` might be in an accordion/collapsible section. **CRUD operations** * **Create/Update:** `setGoal()` action. User inputs target time and optional reward. * **Read:** `XPProgressBar` displays progress. Tooltip shows details. * **Delete:** `clearGoal()` action removes the current goal and progress. * **Validation:** * Target focus time must be a positive number (e.g., HH:MM input converted to seconds). * Reward text is optional string; if provided, sanitize for XSS. * **Pagination:** N/A. * **Soft vs. Hard Delete:** `clearGoal` is a hard delete of the current goal's data. **UX flow** 1. **No Goal Set:** XP bar might be empty or show a prompt. `GoalSetter` accessible. 2. **User Sets Goal:** * Opens `GoalSetter` (e.g., accordion). * Inputs total focus time (e.g., "2h 30m") and reward text (e.g., "Watch a movie"). * Clicks "Set Goal". * UI: `XPProgressBar` updates to show 0% of the new goal. Ship icon at start. Tooltip shows target/reward. 3. **During Focus Sessions:** * After each `timerSlice.completeSession/giveUpSession`, `goalSlice.addFocusTime` is called. * UI: `XPProgressBar` updates. Ship icon animates along the bar. Tooltip shows new progress. 4. **Goal Reached:** * `goalSlice.addFocusTime` detects `accumulatedFocusTime >= targetFocusTime`. * UI: `DestinationReachedModal` appears with hero image, final stats (total accumulated time, perhaps time since goal set), and user-defined reward. * XP Bar shows 100%, ship at destination. 5. **User Acknowledges "Destination Reached":** * Clicks "Clear Goal" or "Set New Goal" in the modal. * UI: Modal closes. `goalSlice.markGoalAsCompletedAndReset()` is called. XP Bar resets. `GoalSetter` ready for new input. 6. **User Clears/Edits Goal Mid-Progress:** * Opens `GoalSetter`. * Clicks "Clear Goal" -> Confirmation -> Goal data reset. * Or, edits values and clicks "Update Goal" -> Confirmation -> Goal data updated (progress resets for the new target). * **Loading States:** Generally none, operations are local and fast. * **Error States:** Input validation errors in `GoalSetter`. Persistence errors handled gracefully. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** Reward text input should be sanitized before display in the modal or elsewhere to prevent XSS if it's ever rendered as HTML. For simple text display, ensure encoding. ```javascript // Example: If rewardText is displayed using innerHTML // const sanitizedReward = DOMPurify.sanitize(rewardText); // element.innerHTML = sanitizedReward; // If displayed as textContent, browser handles encoding // element.textContent = rewardText; // Safer ``` * **OWASP Protections:** XSS prevention for `rewardText`. **Testing** * **Unit Tests (Vitest):** * `goalSlice` reducers/actions: set, add time, clear, progress calculation. * Input validation for goal time. * **Integration Tests:** * `GoalSetter` component correctly calls `goalSlice` actions. * `XPProgressBar` accurately reflects `goalSlice` state. * `timerSlice` correctly calls `goalSlice.addFocusTime` and passes correct duration. * `DestinationReachedModal` shows/hides based on `goalSlice` state. * Persistence of goal state across refreshes. * **E2E Tests (Playwright/Cypress):** * User sets a goal, completes several focus sessions, sees XP bar progress, reaches goal, sees modal, clears goal. * User edits an active goal. * **Performance Tests:** Animation of ship icon on XP bar should be smooth (CSS transforms). **Data management** * **Caching:** `userGoal` state cached in IndexedDB. Hero images for "Destination Reached" modal are bundled (PWA cache). * **Lifecycle:** * **Creation:** User sets a goal via `GoalSetter`. `userGoal` record created/updated in IndexedDB. * **Update:** `accumulatedFocusTime` updated after each focus session. * **Deletion:** User clears goal, or goal is reset after completion. `userGoal` record in IndexedDB is cleared or reset. * **Real-time Needs:** XP bar updates after each session. **Logging & error handling** * **Structured Logs:** * `INFO: Goal set (Target: ${targetFocusTime}s, Reward: "${rewardText}")` * `INFO: Focus time added to goal (Added: ${seconds}s, Accumulated: ${accumulatedFocusTime}s, Target: ${targetFocusTime}s)` * `INFO: Goal reached! (Reward: "${rewardText}")` * `INFO: Goal cleared.` * `WARN: Failed to save/load goal state: ${error.message}` * **Alerts:** N/A for client-side. * **Recovery:** On load, `goalSlice` attempts to hydrate from IndexedDB. If fails, starts with no goal set. **Detailed requirements** (from input) * Goal setup section (e.g., accordion) with input for total focus time & reward text. * XP bar, tool-tippable, ship icon animates. * “Destination reached” modal with pre-defined hero image & summary stats. * Clear/edit actions for current goal with confirmation. * Progress persists across sessions and refreshes until cleared or completed. * No automatic midnight reset. **Implementation guide** * **Pseudocode (`goalSlice` logic):** ```typescript // Zustand goalSlice state state = { targetFocusTime: 0, // seconds rewardText: null, accumulatedFocusTime: 0, // seconds showDestinationReachedModal: false, goalSetTimestamp: null } // Actions function setGoal(targetTime, reward): // Show confirmation dialog if a goal is already active and has progress // On confirm: state.targetFocusTime = targetTime state.rewardText = reward state.accumulatedFocusTime = 0 // Reset progress for new/edited goal state.showDestinationReachedModal = false state.goalSetTimestamp = Date.now() persistGoalStateToIndexedDB(state) function addFocusTime(sessionDurationSeconds): if state.targetFocusTime <= 0: return // No goal set state.accumulatedFocusTime += sessionDurationSeconds if state.accumulatedFocusTime > state.targetFocusTime: // Cap progress at 100% visually state.accumulatedFocusTime = state.targetFocusTime persistGoalStateToIndexedDB(state) if state.accumulatedFocusTime >= state.targetFocusTime and !state.showDestinationReachedModal: state.showDestinationReachedModal = true // Modal will pick one of the bundled hero images // Modal will display state.rewardText, state.accumulatedFocusTime function clearGoal(): // Show confirmation dialog // On confirm: state.targetFocusTime = 0 state.rewardText = null state.accumulatedFocusTime = 0 state.showDestinationReachedModal = false state.goalSetTimestamp = null persistGoalStateToIndexedDB(state) // or clear record function markGoalAsCompletedAndReset(): // Called from DestinationReachedModal clearGoal() // Or a more specific reset that logs completion if needed elsewhere function loadGoal(): persistedData = loadGoalStateFromIndexedDB() if persistedData: state = { ...state, ...persistedData } // Ensure accumulatedFocusTime is not greater than targetFocusTime from old data if state.accumulatedFocusTime > state.targetFocusTime && state.targetFocusTime > 0: state.accumulatedFocusTime = state.targetFocusTime ``` * **Data Flow Steps:** 1. User interacts with `GoalSetter.tsx` -> `goalSlice` action `setGoal`. 2. `goalSlice` updates state, persists. 3. `XPProgressBar.tsx` re-renders based on `goalSlice` state. 4. `timerSlice` completes a session -> calls `goalSlice.addFocusTime`. 5. `goalSlice` updates `accumulatedFocusTime`, checks for goal completion. 6. If goal met, `goalSlice` sets `showDestinationReachedModal = true`. 7. `DestinationReachedModal.tsx` (listening to this flag) displays. 8. User action in modal calls `goalSlice.markGoalAsCompletedAndReset()`. * **Key Edge Cases:** * Setting a goal to 0 or negative time (prevent via validation). * Adding focus time when no goal is set (should be a no-op). * Editing a goal that is already completed (should behave like setting a new goal). * Long reward text: Ensure UI handles overflow gracefully. * Hero image loading: Bundled, so should be fast. Handle missing image path gracefully (fallback). --- **Feature 3: Music Player** **Goal** To provide an in-app instrumental music player with local album/track selection, shuffle, adjustable cross-fade, volume control, and an option to play music only during focus sessions, enhancing the work environment. **API relationships** * **Internal Services:** * `Zustand store (musicSlice)`: Manages player state (current album/track, volume, shuffle, cross-fade duration, play-only-in-session, EQ toggle, player UI state). * `Zustand store (timerSlice)`: `musicSlice` observes `timerSlice.status` to implement "Play-only-in-session". * `Zustand store (appSettingsSlice)`: May hold global SFX volume if shared control. (Prompt indicates separate SFX volume, so this is likely in `appSettingsSlice` or a dedicated `sfxSlice`). * `PersistenceService (IndexedDB)`: Saves player state (current track, volume, shuffle, etc.). * **Browser APIs:** * `HTMLAudioElement`: Two instances for playback and cross-fading. * `Web Audio API` (optional for advanced EQ, but for cross-fade and volume, `HTMLAudioElement` properties are sufficient for MVP). The prompt mentions AudioProvider context which suggests more direct Web Audio API use. * If using Web Audio API directly for playback: `AudioContext`, `AudioBufferSourceNode`, `GainNode`. * **Asset Loading:** * `import.meta.glob`: To discover local MP3 files at build time for populating album/track lists. **Architecture overview** * **Diagram Reference:** `MusicPlayer` UI components interact with `musicSlice`. `musicSlice` controls `HTMLAudioElement` instances (or Web Audio API nodes) and uses `PersistenceService`. It subscribes to `timerSlice` for play-only-in-session logic. Music assets are bundled or loaded via `import.meta.glob`. * **Tech-stack Justification:** * React for UI. Zustand for state. * `HTMLAudioElement` (x2) for simplicity in cross-fading if direct Web Audio API is overkill for MVP. If Web Audio API is used, it offers more control. Decision: Stick to `HTMLAudioElement` for MVP cross-fading to manage complexity, unless smooth cross-fade proves impossible, then escalate to Web Audio API. The prompt says "AudioProvider context or similar with HTMLAudioElement pooling (two audio elements for cross-fading)", so this is the way. * `import.meta.glob` for easy asset discovery in Vite. * **Deployment:** Part of PWA. Music files are assets. User choice of caching MP3s is post-MVP, so MVP will bundle or stream based on PWA plugin config. PRD note "excludes large MP3s" from PWA cache implies they are streamed or selectively cached. For MVP, assume they are part of the app bundle but not aggressively precached by service worker by default unless small. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `musicPlayerState` * **KeyPath:** `id` (e.g., `"current_music_settings"`). * **Structure Example:** ```json { "id": "current_music_settings", "currentAlbumId": "ambient_space_1", "currentTrackPath": "assets/music/ambient_space_1/track3.mp3", "volume": 0.75, // 0.0 to 1.0 "isShuffleOn": false, "crossfadeDuration": 3, // seconds (0-8) "isEqOn": false, // basic toggle, actual EQ processing post-MVP if complex "playOnlyInSession": true, "playbackTime": 123.45 // seconds, current position in track, to resume } ``` * **Indexes:** None. * **Migrations:** Handle in `PersistenceService`. **API design (Zustand `musicSlice` actions & selectors)** * **Actions (examples):** * `loadTrack(albumId: string, trackPath: string)` * `play()` * `pause()` * `nextTrack()` (handles shuffle, cross-fade logic) * `previousTrack()` * `setVolume(level: number)` * `toggleShuffle()` * `setCrossfadeDuration(seconds: number)` * `toggleEq()` * `togglePlayOnlyInSession()` * `loadPlayerStateFromPersistence()` * `_handleTimerStatusChange(timerStatus: string)` (internal, reacts to `timerSlice`) * **Selectors (examples):** * `selectCurrentTrackInfo(): { album: string, title: string, path: string, duration?: number }` * `selectIsPlaying(): boolean` * `selectVolume(): number` * `selectAvailableAlbumsAndTracks(): Album[]` * `selectPlayerUiState(): 'collapsed' | 'expanded'` * **Auth:** N/A. * **Errors:** * Audio file not found/load error: Skip track, log error, notify user subtly. * Browser audio playback restrictions (autoplay): Playback should only start after user interaction (e.g., clicking play button). * **Rate-limit:** N/A. **Frontend structure** * **Component Hierarchy:** * `MusicPlayer.tsx` (Main component, collapsed/expanded views, connects to `musicSlice`) * `PlayerControls.tsx` (Play/pause, next, prev, shuffle, EQ toggle) * `TrackList.tsx` (Dropdown for albums, list of tracks for selected album) * Volume slider, Cross-fade slider, "Play-only-in-session" toggle. * **State Management (Zustand `musicSlice`):** * All states from DB schema example. * `isPlaying: boolean` * `activeAudioElementIndex: 0 | 1` (for cross-fading) * `audioElements: [HTMLAudioElement, HTMLAudioElement]` (managed internally, not in Zustand state directly but refs held by the service/hook that slice actions call) * `tracklist: Album[]` (loaded via `import.meta.glob` and processed) * `Album: { id: string, name: string, tracks: Track[] }` * `Track: { path: string, title: string, duration?: number }` * **Navigation:** Collapsed/expanded mini-player UI. **CRUD operations** * Not a typical CRUD feature. It's about controlling playback and settings. * Settings are Created/Updated (volume, shuffle) and persisted. * Tracks are Read (selected and played). **UX flow** 1. **Initial State:** Player possibly collapsed. Default album/track selected (or first available). Music paused. 2. **User Expands Player:** Shows full controls, track list. 3. **User Selects Album/Track:** Track list updates. Selected track loads into primary audio element. 4. **User Clicks Play:** * Music starts playing. If cross-fading from a previous track, it handles the fade. * "Play" icon changes to "Pause". 5. **User Adjusts Volume/Cross-fade/Shuffle/EQ:** Settings applied immediately. State persists. 6. **Track Ends:** * If shuffle is on, a random track from the current album is chosen. * If shuffle is off, next track in sequence. If last track, loops to first or stops (TBD, loop is common). * Cross-fade to new track begins. 7. **"Play-only-in-session" Logic:** * If ON: Music auto-pauses when focus timer is not 'running'. Auto-resumes when focus timer becomes 'running'. * If OFF: Music playback is independent of focus timer. 8. **Page Refresh:** Player state (current track, time, volume, settings) is restored. If playing, attempts to resume (browser may require interaction). * **Loading States:** Brief moment while a new track loads. Visual feedback (e.g., spinner on play button) if loading is slow. * **Error States:** "Track unavailable" message if an MP3 fails to load. Player skips to next. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** Album/track names derived from file paths are generally safe but should be treated as text. If metadata were user-editable, sanitization would be critical. * **OWASP Protections:** N/A. **Testing** * **Unit Tests (Vitest):** * `musicSlice` actions/reducers: playback logic, settings changes, track selection logic (shuffle, next/prev). * Cross-fade timing logic. * Parsing of track metadata from `import.meta.glob`. * **Integration Tests:** * `MusicPlayer` component interaction with `musicSlice`. * `musicSlice` correctly controlling `HTMLAudioElement` instances. * Persistence of player state. * "Play-only-in-session" responding to `timerSlice` state changes. * **E2E Tests (Playwright/Cypress):** * User plays a track, pauses, changes volume, skips track, toggles shuffle. * Verify cross-fading (visually check volume changes if possible, or assert state). * Verify "Play-only-in-session" behavior with focus timer. * Restore player state on page refresh. * **Performance Tests:** * Smooth cross-fades without audible gaps/clicks. * Low CPU usage during playback. **Data management** * **Caching:** * Player state in IndexedDB. * MP3 files: PRD notes "excludes large MP3s" from PWA cache. For MVP, if files are in `src/assets`, Vite might bundle them. `vite-plugin-pwa` needs configuration to exclude them from precache if they are large, or they should be in `public/` and fetched. The goal is streaming on demand. * Strategy: Put MP3s in `public/assets/music/`. `import.meta.glob` might not work for `public` folder directly for metadata generation at build time. A custom script could generate a JSON manifest of music files in `public/` that the app then loads. Or, keep in `src/assets` and ensure PWA config doesn't precache them all. * Decision based on prompt: `src/assets/music/{album_name}/*.mp3` with `import.meta.glob`. This means Vite processes them. We need to ensure `vite-plugin-pwa` is configured to not precache all of these if they are large, or only precache a small default set. For MVP, let's assume they are reasonably sized and can be part of the main bundle, but not aggressively precached by the SW unless explicitly configured. User setting for caching MP3s is post-MVP. * **Lifecycle:** Player settings created on first use, updated by user, persisted. * **Real-time Needs:** UI updates for track progress, volume changes. **Logging & error handling** * **Structured Logs:** * `INFO: Music playback started (Track: ${trackPath})` * `INFO: Music playback paused (Track: ${trackPath})` * `INFO: Music track changed (New Track: ${trackPath}, By: ${isShuffle ? 'Shuffle' : 'Sequential'})` * `INFO: Music settings updated (Volume: ${volume}, Shuffle: ${isShuffleOn}, ...)` * `ERROR: Failed to load audio track: ${trackPath}, Error: ${errorMessage}` * `WARN: Failed to save/load music player state: ${error.message}` * **Alerts:** N/A. * **Recovery:** * Load state from IndexedDB on app start. If fails, use default settings. * If a track fails to load, attempt to play next track. **Detailed requirements** (from input) * Album dropdown, tracks from `src/assets/music/`. * Shuffle toggle. * Adjustable cross-fade (0-8s slider). * Collapsed/expanded UI. * EQ toggle (basic, actual processing post-MVP). * "Play-only-in-session" toggle. * Master music volume slider. * Separate SFX volume (handled globally or in `appSettingsSlice`). * Optimize bundle size (MP3s streamed/demand-cached). PRD: "excludes large MP3s" from PWA cache. * Smooth cross-fade, no gaps/clicks. * Player state persists. **Implementation guide** * **Pseudocode (Cross-fade & Track Transition):** ```typescript // In music service/hook, called by musicSlice actions audioElements = [new Audio(), new Audio()] activeAudioIndex = 0 pendingAudioIndex = 1 currentVolume = 0.75 crossfadeDurationSec = 3 async function playTrack(trackPath): // If already playing, this is a request to switch track if audioElements[activeAudioIndex].src && !audioElements[activeAudioIndex].paused: await crossfadeToNewTrack(trackPath) else: loadAndPlayDirectly(trackPath) async function loadAndPlayDirectly(trackPath): audioElements[activeAudioIndex].src = trackPath audioElements[activeAudioIndex].volume = currentVolume await audioElements[activeAudioIndex].play() // update Zustand state: isPlaying=true, currentTrack=trackPath async function crossfadeToNewTrack(newTrackPath): // Use the other audio element for the new track pendingAudioIndex = 1 - activeAudioIndex audioElements[pendingAudioIndex].src = newTrackPath audioElements[pendingAudioIndex].volume = 0 // Start silent await audioElements[pendingAudioIndex].play() // Start loading and playing muted // Current track fades out, new track fades in fadeOutElement = audioElements[activeAudioIndex] fadeInElement = audioElements[pendingAudioIndex] startTime = Date.now() interval = setInterval(() => { elapsed = (Date.now() - startTime) / 1000 progress = Math.min(elapsed / crossfadeDurationSec, 1.0) fadeOutElement.volume = currentVolume * (1 - progress) fadeInElement.volume = currentVolume * progress if progress >= 1.0: clearInterval(interval) fadeOutElement.pause() fadeOutElement.src = '' // Release resource activeAudioIndex = pendingAudioIndex // update Zustand state: isPlaying=true, currentTrack=newTrackPath }, 50) // Interval for smooth fade // HTMLAudioElement events ('ended', 'error', 'loadeddata') need to be handled // to trigger next track, report errors, get duration. ``` * **`import.meta.glob` for tracks:** ```typescript // In musicSlice or a service const albumModules = import.meta.glob('/src/assets/music/*/*.mp3'); let albums = {}; for (const path in albumModules) { const pathParts = path.split('/'); const albumName = pathParts[pathParts.length - 2]; const trackName = pathParts[pathParts.length - 1].replace('.mp3', ''); // Basic name if (!albums[albumName]) { albums[albumName] = { id: albumName, name: formatAlbumName(albumName), tracks: [] }; } albums[albumName].tracks.push({ id: path, // Use full path as unique ID path: path, // Path for src title: formatTrackName(trackName) // duration can be fetched later using audio.onloadedmetadata }); } const trackList = Object.values(albums); // This trackList is then set in Zustand state. ``` * **Data Flow Steps:** 1. User interacts with `MusicPlayer.tsx` UI. 2. Actions dispatched to `musicSlice`. 3. `musicSlice` (via service/hook) manipulates `HTMLAudioElement` instances, manages fades. 4. `musicSlice` state updates, UI re-renders. 5. `musicSlice` persists its settings via `PersistenceService`. 6. `musicSlice` listens to `timerSlice.status` for "Play-only-in-session". * **Key Edge Cases:** * Very short tracks and long cross-fade (fade might not complete before track ends). * User rapidly clicks next/prev (debounce or queue actions). * Browser suspending audio context (handle `resume()` on interaction). * MP3 files missing or corrupted (graceful skip and notification). * Limited number of `HTMLAudioElement`s if many audio features run concurrently (pooling helps, but browser limits exist). --- (Continuing with other features. This is a long process, will do my best to maintain detail and consistency.) I will proceed with Starfield / Warp Background, Posture Tracker, Session Summary, Notepad & Action List, SFX Feedback, PWA Offline Shell, AI Buddy Chat, and Focus Booster.```markdown ## File System * Frontend/ * src/ * components/ * FocusTimer/ * FocusTimer.tsx * TimerDisplay.tsx * TimerControls.tsx * GoalReward/ * GoalSetter.tsx * XPProgressBar.tsx * DestinationReachedModal.tsx * MusicPlayer/ * MusicPlayer.tsx * TrackList.tsx * PlayerControls.tsx * Starfield/ * StarfieldCanvas.tsx // Renders the animated background via Canvas/WebGL * PostureTracker/ * PostureTracker.tsx // Main component, manages state, camera access * CalibrationGuide.tsx // UI for guiding user through calibration * FeedbackBar.tsx // Visual feedback on posture * CameraView.tsx // Displays webcam feed if needed, or just an indicator * SessionSummary/ * SessionSummaryModal.tsx // Modal for displaying session stats and notes * Notepad/ * NotepadPanel.tsx // Container for Notepad and Action List tabs * MarkdownEditor.tsx // Component for the Notepad's Markdown input * ActionList.tsx // Component for managing checklist items * AIBuddy/ * AIBuddyChat.tsx // Main chat interface * ChatMessage.tsx // Renders individual chat messages * ModelInteractionService.ts // Service managing Transformers.js model loading & inference * FocusBooster/ * FocusBooster.tsx // Full-screen component for the gaze-lock exercise * BoosterIcon.tsx // Docked icon to launch the booster * shared/ // Common UI elements * Modal.tsx * Button.tsx * Slider.tsx * Input.tsx * Accordion.tsx * Icon.tsx * Spinner.tsx // Loading indicator * ToggleSwitch.tsx * hooks/ // Reusable logic * useTimer.ts * useAudio.ts // For MusicPlayer & SFX * useMediaPipe.ts // Abstraction for MediaPipe Pose (used by PostureTracker) * useLLM.ts // Abstraction for Transformers.js (used by AIBuddyChat) * usePersistentState.ts // Custom hook for easy Zustand-IndexedDB sync for slices * useStarfield.ts // Hook managing canvas rendering logic for Starfield * lib/ // Utility functions * sfxManager.ts // Manages loading and playing SFX assets * timeUtils.ts // Date/time formatting and calculations * domUtils.ts // DOM manipulation helpers (e.g., for screen shake) * markdownUtils.ts // Markdown parsing (if not using a library directly in component) * services/ // Abstractions for external/browser features * persistenceService.ts // Wrapper around localforage/idb-keyval for IndexedDB * assetService.ts // For loading assets like music file lists or hero images if dynamic * workers/ // Web Workers * posture.worker.ts // Runs MediaPipe Pose inference * llm.worker.ts // Runs Transformers.js model inference (if offloaded) * store/ // Zustand global state management * index.ts // Main store setup * slices/ // Individual state slices * appSlice.ts // Global app settings (theme, PWA status, onboarding, performance mode) * timerSlice.ts * goalSlice.ts * musicSlice.ts * starfieldSlice.ts // State for Starfield Background settings & effects * postureSlice.ts * editorSlice.ts // State for Notepad & Action List (notes, tasks) * sfxSlice.ts // SFX volume, mute state * aiBuddySlice.ts * focusBoosterSlice.ts * assets/ * music/ // As previously defined * sfx/ // As previously defined * images/ * hero_goal_1.png * ... (4-9 more) * static_starfield_fallback.jpg // Fallback for Starfield * app_icons/ // PWA icons * fonts/ * styles/ * main.css * variables.css // CSS custom properties for theming, starfield params * App.tsx * main.tsx * index.html * vite-env.d.ts * tsconfig.json * vite.config.ts // Vite build configuration, PWA plugin, `import.meta.glob` handling * service-worker.ts // (Generated or custom) * manifest.webmanifest // (Generated or template) * Backend/ * N/A ## Feature Specifications (Feature 1: Focus Timer & Session Control - Provided previously) (Feature 2: Goal / Reward & XP Progress - Provided previously) (Feature 3: Music Player - Provided previously) --- **Feature 4: Starfield / Warp Background** **Goal** To provide an immersive, animated space background that reacts to application states (e.g., focus session start/pause), offers quality modes for performance, and includes a "Warp-full" focus mode and subtle "thrust shake" effect. **API relationships** * **Internal Services:** * `Zustand store (starfieldSlice)`: Manages quality mode, warp-full state, opacity, animation parameters (speed, density). * `Zustand store (timerSlice)`: `starfieldSlice` observes `timerSlice.status` to trigger "thrust" animations or pause/resume starfield movement. * `Zustand store (appSlice)`: Reads performance mode settings which influence starfield quality defaults. * **Browser APIs:** * `Canvas API` or `WebGL API`: For rendering the starfield. (WebGL preferred for performance with many particles/effects, PixiJS/Three.js or custom). * `requestAnimationFrame`: To drive the animation loop. * CSS Variables: Can be used to dynamically control aspects like overlay opacity driven by Zustand state. **Architecture overview** * **Diagram Reference:** `StarfieldCanvas.tsx` component renders visuals based on state from `starfieldSlice`. `starfieldSlice` is influenced by `timerSlice` (for thrust effects) and `appSlice` (for global performance settings). * **Tech-stack Justification:** * React for component structure. * Canvas/WebGL (e.g., custom implementation or lightweight library like PixiJS) for efficient 2D/3D rendering of many particles. * Zustand for managing visual parameters and state. * CSS for "thrust shake" on a container div, and opacity overlay. * **Deployment:** Part of PWA. Assets (fallback image) bundled. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `appSettings` (shared store, `starfieldSlice` contributes relevant keys) * **KeyPath:** `id` (e.g., `"global_settings"`) * **Relevant Keys in Record:** ```json { // ... other app settings "starfieldQuality": "Standard", // "Off" | "Eco" | "Standard" | "Ultra" "starfieldWarpFullScreen": false, "starfieldOverlayOpacity": 0.3 // 0 to 0.8 } ``` * **Indexes:** N/A for this part of the settings. * **Migrations:** Handled by `appSlice` or `PersistenceService` for the shared settings object. **API design (Zustand `starfieldSlice` and `appSlice` actions & selectors)** * **Actions (examples in `starfieldSlice` or `appSlice`):** * `setStarfieldQuality(quality: 'Off' | 'Eco' | 'Standard' | 'Ultra')` * `toggleWarpFullScreen()` * `setStarfieldOverlayOpacity(opacity: number)` // 0-0.8 * `triggerThrustEffect()` // Called when timer starts, briefly increases speed/density * `setAnimationSpeed(speedMultiplier: number)` // Base speed, can be modified by thrust * **Selectors (examples):** * `selectStarfieldQuality()` * `selectIsWarpFullScreen()` * `selectStarfieldParams(): { speed, density, color, particleSize }` (derived from quality mode) * **Auth:** N/A. * **Errors:** WebGL context loss or unavailable: Fallback to static image or Eco mode. Log error. * **Rate-limit:** N/A for animation updates, but `requestAnimationFrame` naturally limits to display refresh rate. **Frontend structure** * **Component Hierarchy:** * `App.tsx` (renders `StarfieldCanvas` as a background layer) * `StarfieldCanvas.tsx` (props: `quality`, `speed`, `density`, `isPaused`, `isThrusting`, etc., from `starfieldSlice`) * **State Management (Zustand `starfieldSlice`):** * `quality: 'Off' | 'Eco' | 'Standard' | 'Ultra'` * `isWarpFullScreen: boolean` * `overlayOpacity: number` * `isAnimationPaused: boolean` (e.g., during breaks, or if quality is 'Off') * Internal parameters derived from quality (particle count, speed factors). * **State Management (Zustand `appSlice`):** * `performanceMode: 'Eco' | 'Standard' | 'Ultra'` (global setting that `starfieldSlice` can use as a default or constraint for its own quality) **CRUD operations** * N/A. Settings are updated. **UX flow** 1. **Default State:** Starfield animates at 'Standard' quality (or based on `appSlice.performanceMode`). 2. **User Changes Quality Setting:** Animation updates particle density/complexity immediately. 'Off' shows static image or nothing. 'Eco' very low intensity. 3. **Focus Session Starts:** `triggerThrustEffect()`: Starfield briefly "accelerates" (more/faster particles). Subtle "thrust shake" on main UI container div. 4. **Focus Session Pauses/Ends:** Starfield may slow down or revert to normal speed. (Pausing animation during breaks is a "Future Feature - Pause Timer" consideration, for MVP it might just continue or slow slightly based on timer state). 5. **User Toggles "Warp-full":** * ON: Starfield covers screen. UI elements become semi-transparent or hide. * OFF: Returns to normal view. 6. **User Adjusts Overlay Opacity:** If not in "Warp-full", UI elements over starfield become more/less prominent. * **Loading States:** Initial canvas setup should be quick. If using complex shaders/textures, a brief load time might occur, fallback to static image during this. * **Error States:** WebGL error: Show static `static_starfield_fallback.jpg`, log error, potentially disable quality options beyond 'Off' or 'Eco'. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** N/A. * **OWASP Protections:** N/A. **Testing** * **Unit Tests (Vitest):** * `starfieldSlice` logic for state changes and parameter derivation from quality. * Logic for "thrust shake" application (e.g., adding/removing CSS class). * **Integration Tests:** * `StarfieldCanvas` correctly responds to `starfieldSlice` state changes. * Timer start/pause correctly influences starfield animation (speed, thrust effect). * Performance settings in `appSlice` correctly influence `starfieldSlice` defaults/behavior. * **E2E Tests (Playwright/Cypress):** * Visually (snapshot) verify different quality modes (if feasible). * Test "Warp-full" mode toggle and UI opacity changes. * Verify "thrust shake" and starfield acceleration on session start. * **Performance Tests:** * Measure CPU/GPU usage for each quality mode. Target <10-15% CPU on mid-range laptop for Eco/Standard. * Maintain 60 FPS for animations in Standard/Ultra on capable hardware. **Data management** * **Caching:** Settings (quality, warp-full state, opacity) persisted in `appSettings` in IndexedDB. Static fallback image cached by PWA. * **Lifecycle:** Settings are user-configurable and persist. Animation state is dynamic. * **Real-time Needs:** Smooth 60 FPS animation. Immediate response to setting changes. **Logging & error handling** * **Structured Logs:** * `INFO: Starfield quality set to ${quality}` * `INFO: Starfield thrust effect triggered.` * `ERROR: WebGL context lost/failed to initialize for Starfield. Falling back. Error: ${errMessage}` * `WARN: Starfield performance for quality ${quality} exceeds target on this device.` (If measurable) * **Alerts:** N/A. * **Recovery:** On WebGL error, fall back to static image or simpler Canvas 2D animation. Persist this degraded state if the error is persistent (e.g., no WebGL support). **Detailed requirements** (from input) * Always-on (unless 'Off'). Quality modes: Off / Eco / Standard / Ultra. * "Warp-full" toggle, opacity adjustable (0-80%). * "Thrust shake" effect on primary container div. * Starfield "accelerates" on session start (linked to Timer state). * CPU/GPU usage capped. Graceful fallback if WebGL fails. Performance settings respected. **Implementation guide** * **Pseudocode (Starfield Rendering in `StarfieldCanvas.tsx` / `useStarfield` hook):** ```typescript // Simplified pseudocode for star generation and movement MAX_STARS_ULTRA = 2000; MAX_STARS_STANDARD = 1000; MAX_STARS_ECO = 200; stars = []; currentQuality = 'Standard'; // from Zustand state isPaused = false; // from Zustand state baseSpeed = 1.0; // from Zustand state, influenced by quality thrustMultiplier = 1.0; // temporary boost function initializeStars(canvas): starCount = getStarCountForQuality(currentQuality); stars = []; for i = 0 to starCount: stars.push({ x: random(0, canvas.width), y: random(0, canvas.height), z: random(1, canvas.width), // z for parallax/speed size: random(1,3) }); function drawStar(ctx, star): // Map star.z to screen position and size for 3D effect screenX = (star.x / star.z) * canvas.width/2 + canvas.width/2; screenY = (star.y / star.z) * canvas.height/2 + canvas.height/2; radius = Math.max(0.1, star.size / star.z); // Draw circle/rectangle at screenX, screenY with radius function updateStars(deltaTime): if isPaused and thrustMultiplier <= 1.0: return; effectiveSpeed = baseSpeed * thrustMultiplier; for star in stars: star.z -= effectiveSpeed * deltaTime * (currentQuality === 'Eco' ? 0.5 : 1); // Slower for Eco if star.z <= 0: // Reset star if behind camera star.z = canvas.width; star.x = random(-canvas.width/2, canvas.width/2) * star.z; // Re-spread star.y = random(-canvas.height/2, canvas.height/2) * star.z; function animationLoop(timestamp): deltaTime = calculateDeltaTime(timestamp); clearCanvas(); updateStars(deltaTime); for star in stars: drawStar(canvasContext, star); if thrustMultiplier > 1.0: thrustMultiplier -= 0.05; // Decay thrust effect requestAnimationFrame(animationLoop); // In Zustand starfieldSlice function triggerThrustEffect(): state.thrustMultiplier = 3.0; // e.g., 3x speed temporarily // For screen shake: // mainUiContainer = document.getElementById('main-ui-container'); // mainUiContainer.classList.add('shake-effect'); // setTimeout(() => mainUiContainer.classList.remove('shake-effect'), 100); // CSS for shake: // .shake-effect { animation: shake 0.1s cubic-bezier(.36,.07,.19,.97) both; } // @keyframes shake { ... } ``` * **Data Flow Steps:** 1. `App.tsx` includes `StarfieldCanvas.tsx`. 2. `StarfieldCanvas.tsx` subscribes to `starfieldSlice` and `appSlice` (for performance mode). 3. User changes quality in Settings UI -> `appSlice`/`starfieldSlice` action updates state. 4. `StarfieldCanvas.tsx` receives new props/state, re-initializes or adjusts parameters (e.g., `initializeStars`, `baseSpeed`). 5. `timerSlice.status` changes to 'running' -> `starfieldSlice.triggerThrustEffect()` called. 6. `StarfieldCanvas.tsx` detects thrust, increases animation speed temporarily. 7. Animation loop in `StarfieldCanvas.tsx` (or `useStarfield` hook) continuously updates and renders. * **Key Edge Cases:** * Browser window resize: Canvas must be resized and star positions recalculated/reinitialized. * Device pixel ratio changes: Affects canvas sharpness, may need adjustment. * Very low-end devices: 'Eco' mode should be extremely lightweight or 'Off' by default. * WebGL context loss: Must be handled gracefully, falling back to Canvas 2D or static image. --- **Feature 5: Posture Tracker** **Goal** To provide webcam-based posture detection with a user-initiated calibration step, live visual feedback, and configurable sensitivity and nudge delays, helping users maintain good posture during work sessions. **API relationships** * **Internal Services:** * `Zustand store (postureSlice)`: Manages enabled state, calibration data, sensitivity, nudge delay, current posture status, camera active status. * `Zustand store (appSlice)`: Reads performance settings (may affect inference polling rate if needed). * `Web Worker (posture.worker.ts)`: Offloads MediaPipe Pose inference. * `SFXManager`: For nudge sound (if any). * **Browser APIs:** * `MediaDevices API (navigator.mediaDevices.getUserMedia)`: To access webcam stream. * `HTMLVideoElement`: To display webcam feed (can be hidden or small view). * `OffscreenCanvas` (optional): For sending frames to worker without displaying video. **Architecture overview** * **Diagram Reference:** `PostureTracker` UI components interact with `postureSlice`. `postureSlice` actions trigger camera access via `MediaDevices API`. Video frames are sent to `posture.worker.ts`, which uses MediaPipe Pose. Results are sent back to `postureSlice` to update posture status. * **Tech-stack Justification:** * React for UI. Zustand for state. * MediaPipe Pose (WASM): For robust pose estimation, client-side, good performance. * Web Worker: Essential for offloading inference to prevent UI jank. * **Deployment:** Part of PWA. MediaPipe models (WASM, .tflite) need to be bundled or fetched. `vite-plugin-pwa` should be configured to cache these models if bundled. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `appSettings` (shared store, `postureSlice` contributes relevant keys) * **Relevant Keys in Record:** ```json { // ... other app settings "postureTrackerEnabled": false, "postureCalibrationData": null, // { keypoints: [...], timestamp: ... } or more abstract representation "postureSensitivity": 0.5, // e.g., 0.0 to 1.0 representing % deviation allowed "postureNudgeDelay": 15, // seconds poor posture held before nudge "postureNudgeEnabled": true } ``` * **Indexes:** N/A. * **Migrations:** Handled by `appSlice` or `PersistenceService`. **API design (Zustand `postureSlice` actions & selectors)** * **Actions (examples):** * `enablePostureTracker()`: Requests camera permission, starts video stream, initializes worker. * `disablePostureTracker()`: Stops camera, terminates worker. * `startCalibration()`: Sets UI state for calibration. * `confirmCalibration(poseData: Pose)`: Saves `poseData` as `postureCalibrationData`. * `setSensitivity(value: number)` * `setNudgeDelay(seconds: number)` * `toggleNudges(enable: boolean)` * `_updatePoseFromWorker(poseData: Pose)`: Internal action called by worker message handler. Compares to calibrated pose, updates `currentPostureIsGood`, manages nudge timer. * `loadPostureSettingsFromPersistence()` * **Selectors (examples):** * `selectIsPostureTrackerEnabled(): boolean` * `selectIsCalibrated(): boolean` * `selectCurrentPostureIsGood(): boolean | null` (null if not active/calibrating) * `selectIsCameraActive(): boolean` * `selectCameraPermissionStatus(): 'granted' | 'denied' | 'prompt'` * **Auth:** Camera permission managed by browser, explicitly requested. * **Errors:** Camera access denied/unavailable. MediaPipe model load failure. Worker errors. * **Rate-limit:** Inference polling interval (e.g., 500ms-1s) to manage performance. **Frontend structure** * **Component Hierarchy:** * `PostureTracker.tsx` (Main UI, buttons to enable/disable, calibrate, settings sliders) * `CameraView.tsx` (Optional, small display of webcam feed, or just an indicator light) * `CalibrationGuide.tsx` (Overlay/modal to guide user during calibration) * `FeedbackBar.tsx` (Simple visual bar: green/yellow/red for posture) * (Visual/text nudge element, could be a toast or part of `FeedbackBar`) * **State Management (Zustand `postureSlice`):** * States from DB schema example. * `isCameraActive: boolean` * `cameraPermission: 'prompt' | 'granted' | 'denied'` * `isCalibrating: boolean` * `currentPostureIsGood: boolean | null` * `poorPostureSince: number | null` (timestamp when poor posture started, for nudge delay) * `showNudge: boolean` * **Navigation:** Settings might be in a sub-panel. Calibration is a specific UI mode. **CRUD operations** * N/A. Settings are updated. Calibration data is "Created". **UX flow** 1. **Initial State:** Tracker disabled. UI shows "Enable Posture Tracker" button. 2. **User Clicks "Enable":** * Browser permission prompt for camera. * If granted: Camera starts (indicator ON). `posture.worker.ts` initialized, MediaPipe model loads. * UI shows "Calibrate" button, sensitivity/delay sliders. 3. **User Clicks "Calibrate":** * `CalibrationGuide.tsx` appears with instructions (e.g., "Sit straight, look ahead"). * Countdown or "Hold Pose" message. * User confirms. System captures current pose as `postureCalibrationData`. * `FeedbackBar.tsx` becomes active. 4. **Live Tracking:** * Worker processes frames, sends pose data to `postureSlice`. * `postureSlice` compares current pose to calibrated pose using sensitivity. * `FeedbackBar` updates (green/yellow/red). * If posture is bad for longer than `nudgeDelay`, `showNudge` becomes true. Nudge (visual/text/SFX) appears. 5. **User Adjusts Settings:** Sensitivity/delay sliders update behavior immediately. 6. **User Disables Tracker:** Camera stops, worker terminates. Settings persist. * **Loading States:** Model loading for MediaPipe (show spinner). Camera starting. * **Error States:** * Camera permission denied: Message with instructions how to grant. * Camera not found: Message. * Model load error: Message, disable feature. * Worker error: Log, attempt to restart worker, or disable feature. **Security** * **Auth Flow:** Explicit user consent for camera via browser `getUserMedia` prompt. Clear indicator when camera is active. Easy way for user to revoke permission via browser settings (link/instructions provided). * **Roles:** N/A. * **Sanitization:** N/A for pose data. * **OWASP Protections:** N/A. Clickjacking on camera permission UI is a browser concern. **Testing** * **Unit Tests (Vitest):** * `postureSlice` actions/reducers: state transitions, settings updates, nudge logic. * Posture comparison logic (deviation calculation). * Worker message handling. * **Integration Tests:** * `PostureTracker` component interaction with `postureSlice`. * `postureSlice` correctly communicating with `posture.worker.ts` (mock worker). * Camera permission flow (mock `getUserMedia`). * Persistence of settings. * **E2E Tests (Playwright/Cypress with Fake Media Stream):** * User enables tracker, grants permission. * User calibrates (mock good pose data). * Simulate pose changes (send mock data from fake worker) to verify feedback bar and nudge. * Test settings adjustments. * **Performance Tests:** * Measure inference time in worker (target ≤ 15ms when polled, e.g., every 500-1000ms). * Overall CPU usage impact of the feature. **Data management** * **Caching:** Settings and calibration data in `appSettings` (IndexedDB). MediaPipe models cached by PWA Service Worker or browser if fetched. * **Lifecycle:** * Settings: User-configurable, persist. * Calibration data: Created by user, persists until re-calibrated. * Live pose data: Transient, processed in real-time. * **Real-time Needs:** Live feedback bar updates based on ~0.5-1Hz pose analysis. **Logging & error handling** * **Structured Logs:** * `INFO: Posture Tracker enabled/disabled.` * `INFO: Camera permission status: ${status}.` * `INFO: Posture calibration started/completed.` * `INFO: Posture nudge triggered.` * `ERROR: Failed to get camera access: ${error.message}.` * `ERROR: MediaPipe model load failed in worker: ${error.message}.` * `ERROR: Posture worker error: ${error.message}.` * `WARN: Failed to save/load posture settings: ${error.message}.` * **Alerts:** N/A. * **Recovery:** * Permission denied: Guide user. * Camera/Model/Worker failure: Disable feature, notify user, log error. Offer to retry. * Settings load failure: Use default settings. **Detailed requirements** (from input) * Calibration step. Live feedback bar. Sensitivity slider. Nudge delay slider & toggle. * Visual/text nudge. Clear display of camera permission status & link to revoke. * MediaPipe Pose (WASM) in Web Worker. * Avg inference time target (≤ 15ms, polling at 500ms-1s). This means the processing of one frame in the worker is fast, not that it runs every 15ms. * Camera must be explicitly user-started. Clear indicator when camera active. State persists. **Implementation guide** * **Pseudocode (`posture.worker.ts`):** ```typescript // posture.worker.ts importScripts('mediapipe_pose_solution_WASM_loader.js'); // Path to MediaPipe let poseEstimator = null; self.onmessage = async (event) => { const { type, payload } = event.data; if (type === 'INIT') { poseEstimator = new Pose({locateFile: (file) => `path_to_mediapipe_assets/${file}`}); poseEstimator.setOptions({ modelComplexity: 1 /* or 0 for faster */ }); poseEstimator.onResults(results => { self.postMessage({ type: 'POSE_RESULTS', payload: results.poseLandmarks }); }); await poseEstimator.initialize(); self.postMessage({ type: 'INIT_DONE' }); } else if (type === 'PROCESS_FRAME' && poseEstimator) { // payload is ImageData or OffscreenCanvas await poseEstimator.send({ image: payload }); } else if (type === 'CLOSE') { if (poseEstimator) await poseEstimator.close(); self.close(); } }; ``` * **Pseudocode (Posture Comparison in `postureSlice`):** ```typescript // postureSlice.ts (simplified) state = { calibratedPose: null, // { keypoints: [{x,y,z,visibility}, ...], referenceAngle: X } sensitivity: 0.5, // Lower is stricter } function calculateDeviation(currentKeypoints, calibratedKeypoints): number { // Example: Compare shoulder alignment, head tilt, spine angle // 1. Calculate key angles/distances from currentKeypoints (e.g., ear-shoulder-hip angle) // 2. Compare with similar angles/distances from calibratedKeypoints // 3. Aggregate deviations into a single score (0.0 = perfect, 1.0 = very bad) // This requires careful selection of landmarks and geometric calculations. // E.g., deviation = Math.abs(currentAngle - calibratedAngle) / maxExpectedAngleDeviation; let totalDeviation = 0; // For vertical alignment of EAR_SHOULDER_HIP: // calibratedShoulderX = calibratedKeypoints[SHOULDER_LEFT].x // currentShoulderX = currentKeypoints[SHOULDER_LEFT].x // deviation += Math.abs(currentShoulderX - calibratedShoulderX) / (screenWidth * 0.1); // Normalized by 10% of screen // ... more checks for other keypoints and relationships ... return Math.min(1.0, totalDeviation / numberOfChecks); // Average normalized deviation } function _updatePoseFromWorker(currentPoseLandmarks): if (!state.calibratedPose) return; const deviationScore = calculateDeviation(currentPoseLandmarks, state.calibratedPose.keypoints); if (deviationScore > (1 - state.sensitivity)) { // Higher sensitivity means lower tolerance for deviation state.currentPostureIsGood = false; if (!state.poorPostureSince) state.poorPostureSince = Date.now(); if (Date.now() - state.poorPostureSince > state.postureNudgeDelay * 1000 && state.postureNudgeEnabled) { state.showNudge = true; // playNudgeSFX(); // If applicable } } else { state.currentPostureIsGood = true; state.poorPostureSince = null; state.showNudge = false; } ``` * **Data Flow Steps:** 1. User enables tracker in `PostureTracker.tsx`. Permission requested. 2. If granted, `postureSlice` initializes worker, starts video stream via `getUserMedia`. 3. Video frames (e.g., from hidden `<video>` element or `OffscreenCanvas`) are periodically sent to `posture.worker.ts`. 4. Worker performs pose estimation, sends `poseLandmarks` back to `postureSlice`. 5. `postureSlice` compares to calibration data, updates `currentPostureIsGood`, manages nudge timer/display. 6. UI components (`FeedbackBar.tsx`, nudge indicators) re-render. * **Key Edge Cases:** * User moves out of frame / poor lighting: MediaPipe results might be low confidence or null. Handle gracefully (e.g., posture unknown). * Background processing limits by browser: Ensure worker is efficient. * Multiple cameras: Allow user to select if feasible (post-MVP). MVP uses default. * Calibration in unusual pose: Nudges might be inaccurate. Emphasize correct calibration posture. --- **Feature 6: Session Summary** **Goal** To display a modal after each focus session, summarizing key performance metrics (duration, distractions, posture quality), showing streak status, allowing users to add reflective notes, and prompting for the next steps. **API relationships** * **Internal Services:** * `Zustand store (timerSlice)`: Provides session duration, distraction count. Triggers modal display. * `Zustand store (postureSlice)`: Provides posture quality % for the session (if active). * `Zustand store (goalSlice)`: Provides streak status (based on distraction count, managed by `goalSlice` or a shared gamification slice). Modal display can trigger "Destination Reached" logic if goal is met. * `Zustand store (editorSlice)`: Saves session notes to IndexedDB. * `Zustand store (aiBuddySlice)`: Provides a simple text prompt for "what's next". * `PersistenceService (IndexedDB)`: For saving session notes (via `editorSlice`). * **Browser APIs:** N/A. **Architecture overview** * **Diagram Reference:** `SessionSummaryModal.tsx` component displays data from `timerSlice`, `postureSlice`, `goalSlice`, and `aiBuddySlice`. User input (notes) is handled by `editorSlice` which uses `PersistenceService`. * **Tech-stack Justification:** React for modal UI, Zustand for state aggregation and actions. IndexedDB for notes. * **Deployment:** Part of PWA. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `sessionNotes` (managed by `editorSlice`) * **KeyPath:** `sessionId` (passed from `timerSlice` when session ends) or `timestamp` if notes are more general. For MVP, let's assume notes are tied to `sessionId`. * **Structure Example:** ```json { "sessionId": "uuid-v4-string-from-completed-session", // Or timestamp "notes": "This session went well. Focused on chapter 3.", "timestamp": 1678890000000 // When notes were last saved } ``` Alternative: A single `journal` object store where each entry is a note with a timestamp, and session ID is optional metadata. For MVP, let's assume one note field per summary, linked to that session if possible, or just a general "last session thoughts" field. The prompt implies notes auto-save to IndexedDB, and the chatbot prompt leads to the notes area. This suggests a general notes area that can be contextualized post-session. Let's refine: `editorSlice` will manage a general "session reflection" note, which is auto-saved. * **Object Store:** `appState` (or a dedicated `reflectionsStore`) * **KeyPath:** `id` (e.g. `"current_session_reflection"`) * **Structure Example:** ```json { "id": "current_session_reflection", "text": "Today's reflection on last session...", "lastUpdated": 1678890000000 } ``` * **Indexes:** None for a single reflection note. If storing multiple historical notes, index by `timestamp` or `sessionId`. * **Migrations:** Handled by `PersistenceService` / `editorSlice`. **API design (Zustand `timerSlice`, `postureSlice`, `goalSlice`, `editorSlice`, `aiBuddySlice`)** * **Actions (examples):** * `timerSlice.showSessionSummary(sessionData: object)`: Called internally when session ends. Sets data for modal. * `sessionData` would include `{ actualDuration, distractionCount, sessionId }`. * `editorSlice.updateSessionReflectionNote(text: string)`: Saves note text to state and IndexedDB. * `editorSlice.loadSessionReflectionNote()` * **Selectors (examples):** * `timerSlice.selectLastSessionData()` * `postureSlice.selectLastSessionPostureQuality(): number | null` (this requires `postureSlice` to track aggregate quality *during* a session if `timerSlice.sessionId` is known to it) * *Refinement*: `postureSlice` needs to accumulate posture data (e.g., % good samples) during an active session, tagged with `timerSlice.sessionId`. When session ends, this data is retrieved. * `goalSlice.selectCurrentStreak(): number` * `editorSlice.selectCurrentSessionReflectionNote(): string` * `aiBuddySlice.selectSimpleMotivationalPrompt(): string` (e.g., "You made progress, yes? What's next?") * **Auth:** N/A. * **Errors:** Persistence errors for notes. * **Rate-limit:** N/A. Auto-save for notes should be throttled (e.g., every few seconds or on blur). **Frontend structure** * **Component Hierarchy:** * `SessionSummaryModal.tsx` (Displays all info, includes textarea for notes) * (This modal is likely rendered by `App.tsx` or a top-level layout component, visibility controlled by `timerSlice.showSummaryModal` flag and `timerSlice.lastSessionData`.) * **State Management:** * `timerSlice`: `showSummaryModal: boolean`, `lastSessionData: { duration, distractions, sessionId }`. * `postureSlice`: Needs to store `postureQualityForSessionId: { [sessionId: string]: number }` or similar. * `editorSlice`: `currentReflectionNote: string`. * **Navigation:** Modal display. **CRUD operations** * **Notes (within `editorSlice`):** * **Create/Update:** User types in textarea, `editorSlice.updateSessionReflectionNote` called (auto-save). * **Read:** Note displayed in textarea when modal opens. * **Validation:** Max length for notes? (Soft limit). Sanitize for display if ever rendered as HTML (not in textarea). * **Pagination:** N/A. * **Soft vs. Hard Delete:** Notes are overwritten or appended to a log. For MVP, a single reflection note is overwritten. **UX flow** 1. **Focus Session Ends (Completed/Given Up):** * `timerSlice` sets `showSummaryModal = true` and populates `lastSessionData`. * `SessionSummaryModal.tsx` appears. 2. **Modal Content:** * Displays: Actual focus duration, distraction count. * Posture quality % (if tracker was active, else "N/A" or hidden). * Streak badge/indicator (e.g., "Streak x3!"). * Textarea for notes, pre-filled with any existing reflection or empty. * AI Buddy text prompt: "You made progress, yes? What’s next?" 3. **User Interacts:** * Types notes in textarea. Notes auto-save to IndexedDB frequently. * User clicks "Close" or "Start Next Session" (or similar action button). 4. **Modal Closes:** `timerSlice.showSummaryModal = false`. * If "Destination Reached" condition is met by this session, that modal might appear next. * **Loading States:** None, data should be readily available from Zustand slices. * **Error States:** If notes fail to save, a subtle non-blocking error. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** Notes text, if ever displayed outside a textarea as HTML, needs sanitization. Inside textarea, it's safe. * **OWASP Protections:** XSS if notes are rendered as HTML. **Testing** * **Unit Tests (Vitest):** * `editorSlice` actions for note saving/loading. * Logic for calculating posture quality % for a session in `postureSlice`. * Streak calculation logic (if part of this feature's display, or in `goalSlice`). * **Integration Tests:** * `SessionSummaryModal` correctly displays data from all relevant slices. * Notes auto-save to IndexedDB and are reloaded. * Modal correctly triggers "Destination Reached" logic in `goalSlice` if applicable. * **E2E Tests (Playwright/Cypress):** * Complete a session, verify all data points in summary modal. * Type notes, close modal, reopen (e.g., by ending another short session), verify notes persisted. * Verify streak display based on distraction count. * **Performance Tests:** Modal should appear quickly. Textarea input should be responsive. **Data management** * **Caching:** Session notes in IndexedDB. Other displayed data is transient or from other persisted states. * **Lifecycle:** Notes are created/updated by user per session (or as a running reflection). Persist until explicitly cleared by user (post-MVP feature) or due to data limits. * **Real-time Needs:** N/A beyond responsive UI. **Logging & error handling** * **Structured Logs:** * `INFO: Session Summary displayed (SessionID: ${sessionId}, Duration: ${d}, Distractions: ${dc}, Posture: ${pq}%)` * `INFO: Session notes saved/updated.` * `WARN: Failed to save session notes: ${error.message}.` * **Alerts:** N/A. * **Recovery:** If notes fail to load, textarea is empty. If other data points fail to load, show "N/A". **Detailed requirements** (from input) * Metrics: Actual duration, distraction count, posture quality %. * Streak badge/indicator (if distraction count ≤ threshold, e.g., 3). * Notes textarea, auto-save to IndexedDB. * Simplified AI Buddy prompt ("you made progress,yes? What’s next?") leading to notes area. * No data loss for notes on accidental close (frequent auto-save). * Summary accurately triggers "Destination Reached" if goal met. **Implementation guide** * **Pseudocode (Posture Quality Aggregation in `postureSlice`):** ```typescript // postureSlice.ts state = { // ... other posture state _currentSessionPostureSamples: { good: 0, total: 0 }, _activeSessionIdForPosture: null, postureQualityHistory: {} // { [sessionId]: percentage } } // When timerSlice starts a session with a sessionId: function _startPostureTrackingForSession(sessionId): state._activeSessionIdForPosture = sessionId; state._currentSessionPostureSamples = { good: 0, total: 0 }; // When _updatePoseFromWorker determines currentPostureIsGood: function _recordPostureSample(isGood): if (state._activeSessionIdForPosture) { state._currentSessionPostureSamples.total++; if (isGood) state._currentSessionPostureSamples.good++; } // When timerSlice ends a session: function _finalizePostureQualityForSession(sessionId): if (state._activeSessionIdForPosture === sessionId && state._currentSessionPostureSamples.total > 0) { const quality = (state._currentSessionPostureSamples.good / state._currentSessionPostureSamples.total) * 100; state.postureQualityHistory[sessionId] = Math.round(quality); // Persist postureQualityHistory if needed long term, or just keep last few } state._activeSessionIdForPosture = null; state._currentSessionPostureSamples = { good: 0, total: 0 }; return state.postureQualityHistory[sessionId] || null; // Return for current summary // Selector function selectLastSessionPostureQuality(sessionId): // Pass sessionId from timerSlice.lastSessionData return state.postureQualityHistory[sessionId] || "N/A"; ``` * **Data Flow Steps:** 1. `timerSlice` ends a session, sets `showSummaryModal=true`, `lastSessionData={...}`. 2. `SessionSummaryModal.tsx` reads `lastSessionData` from `timerSlice`. 3. It reads posture quality for `lastSessionData.sessionId` from `postureSlice`. 4. It reads streak status from `goalSlice` (based on `lastSessionData.distractionCount`). 5. It reads/displays notes from `editorSlice`. User input updates `editorSlice`, which auto-saves. 6. It displays prompt from `aiBuddySlice`. 7. On modal close, `timerSlice` checks if `goalSlice.isGoalMet` is true; if so, `DestinationReachedModal` is triggered. * **Key Edge Cases:** * Posture tracker not active during session: Posture quality shows "N/A". * No distractions: Streak maintained/incremented. * Notes textarea: Handle max length gracefully if any. Frequent auto-save needs throttling. --- **Feature 7: Notepad & Action List** **Goal** To provide a simple, persistent Markdown notepad and a checklist (action list) within a collapsible side panel, allowing users to jot down thoughts and manage tasks related to their work. **API relationships** * **Internal Services:** * `Zustand store (editorSlice)`: Manages notepad content (Markdown text) and action list items (array of tasks). * `PersistenceService (IndexedDB)`: Saves notepad content and action list items. * **Browser APIs:** N/A directly beyond DOM. **Architecture overview** * **Diagram Reference:** `NotepadPanel.tsx` and its children (`MarkdownEditor.tsx`, `ActionList.tsx`) interact with `editorSlice`. `editorSlice` uses `PersistenceService`. * **Tech-stack Justification:** * React for UI. Zustand for state. * Simple textarea for Markdown input. Manual Markdown-to-HTML for display (or lightweight lib like `marked` or `react-markdown`). For action list, standard React list management. * IndexedDB for persistence. * **Deployment:** Part of PWA. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `editorData` * **KeyPath:** `id` (e.g., `"user_notes_tasks"`) * **Structure Example:** ```json { "id": "user_notes_tasks", "notepadMarkdown": "# My Notes\n\n- Point 1\n- Point 2", "actionListItems": [ { "id": "uuid-1", "text": "Research topic A", "isComplete": false, "order": 0 }, { "id": "uuid-2", "text": "Draft outline", "isComplete": true, "order": 1 }, { "id": "uuid-3", "text": "Write intro", "isComplete": false, "order": 2 } ], "lastUpdatedNotepad": 1678890000000, "lastUpdatedActionList": 1678890000000 } ``` * **Indexes:** None for a single record. * **Migrations:** Handled by `PersistenceService` / `editorSlice`. **API design (Zustand `editorSlice` actions & selectors)** * **Actions (examples):** * `updateNotepadMarkdown(markdown: string)`: Updates state, throttled save to IndexedDB. * `addListItem(text: string)`: Adds new task, assigns ID and order, saves. * `editListItem(id: string, newText: string)`: Updates task text, saves. * `toggleListItemComplete(id: string)`: Toggles completion status, saves. * `deleteListItem(id: string)`: Removes task, saves. * `reorderListItems(newOrderArray: ActionListItem[])`: Updates order of all items, saves. * `loadEditorData()`: Loads from IndexedDB on app start. * **Selectors (examples):** * `selectNotepadMarkdown(): string` * `selectActionListItems(): ActionListItem[]` (sorted by `order`) * **Auth:** N/A. * **Errors:** Persistence errors. * **Rate-limit:** Auto-save for notepad markdown throttled. **Frontend structure** * **Component Hierarchy:** * `NotepadPanel.tsx` (Collapsible side panel, tabs for "Notepad" and "Action List") * `MarkdownEditor.tsx` (Textarea for input, potentially a preview pane for rendered Markdown) * `ActionList.tsx` (Renders list items, inputs for new items, controls for edit/delete/toggle, drag-and-drop handles) * **State Management (Zustand `editorSlice`):** * `notepadMarkdown: string` * `actionListItems: ActionListItem[]` * `ActionListItem: { id: string, text: string, isComplete: boolean, order: number }` * `activeTab: 'notepad' | 'actionList'` * **Navigation:** Tabs within the panel. Panel collapse/expand. **CRUD operations** * **Notepad:** * Create/Update: Typing in textarea. * Read: Displayed in textarea (edit) or rendered preview (view). * **Action List Items:** * Create: `addListItem`. * Read: Displayed in list. * Update: `editListItem`, `toggleListItemComplete`, `reorderListItems`. * Delete: `deleteListItem`. * **Validation:** * Task text should not be empty. * Markdown input is free-form. * **Pagination:** N/A for MVP. For very long action lists, virtualization could be post-MVP. * **Soft vs. Hard Delete:** Tasks are hard deleted. **UX flow** 1. **Panel Collapsed:** Icon/button to expand. 2. **Panel Expanded:** Defaults to one tab (e.g., Notepad). * **Notepad Tab:** * Textarea shows current Markdown. User types, content auto-saves. * (Optional) Preview pane updates. * **Action List Tab:** * Shows list of tasks. Completed tasks might be styled differently (e.g., strikethrough). * Input field to add new task. Press Enter or click "Add" button. * Each task has checkbox, edit icon, delete icon. * User can drag tasks to reorder (using a drag-and-drop library or HTML5 DnD API). 3. **Keyboard Shortcuts:** * Focus on panel: `Ctrl/Cmd + Alt + N` (example) * New item in focused list/notepad: `Ctrl/Cmd + N` * **Loading States:** Data loaded from IndexedDB on app start, should be near-instant. * **Error States:** Persistence failure shown subtly. **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** * Markdown input: If rendered to HTML (e.g., in a preview pane), use a sanitizer like DOMPurify along with the Markdown parser (`new MarkdownIt().use(dompurify)` or `DOMPurify.sanitize(marked(text))`). * Action list item text: Sanitize if rendered as HTML anywhere. If always text in inputs/text nodes, generally safe. * **OWASP Protections:** XSS if rendering user-supplied Markdown/text as HTML. **Testing** * **Unit Tests (Vitest):** * `editorSlice` actions/reducers for both notepad and action list (add, edit, delete, reorder, toggle, markdown update). * Markdown parsing/sanitization logic if custom. * Drag-and-drop reordering logic. * **Integration Tests:** * Components correctly interact with `editorSlice`. * Data correctly persists to and loads from IndexedDB. * Throttling of notepad auto-save. * **E2E Tests (Playwright/Cypress):** * User opens panel, types in notepad, switches to action list. * User adds, edits, completes, reorders, and deletes tasks. * Verify data persistence across page reloads for both notepad and action list. * Test keyboard shortcuts. * **Performance Tests:** Responsiveness of textarea for large Markdown notes. Smooth drag-and-drop for action list. **Data management** * **Caching:** All data in `editorData` object in IndexedDB. * **Lifecycle:** Data created/updated by user, persists indefinitely until user deletes it or clears app data. * **Real-time Needs:** UI updates immediately on user input. **Logging & error handling** * **Structured Logs:** * `INFO: Notepad content updated.` * `INFO: Action list item added/updated/deleted/reordered.` * `WARN: Failed to save/load editor data: ${error.message}.` * **Alerts:** N/A. * **Recovery:** On load failure, start with empty notepad/list. Show non-blocking error to user if save fails. **Detailed requirements** (from input) * Notepad: Free-form textarea, basic Markdown. * Action List: Add/edit/delete, mark complete, drag-to-reorder. * Collapse/expand side panel. * Offline-first: Data in IndexedDB. * Basic keyboard shortcuts. * Data structured for potential future export (current schema is reasonable for JSON export). **Implementation guide** * **Pseudocode (Action List Reorder in `editorSlice`):** ```typescript // editorSlice.ts // Using a library like dnd-kit or react-beautiful-dnd for drag and drop. // The library would typically provide onDragEnd(result) callback. function reorderListItems(dragResult): const { source, destination } = dragResult; if (!destination) return; // Dropped outside a droppable area if (source.index === destination.index) return; // No change const currentItems = [...state.actionListItems]; // Create a mutable copy const [movedItem] = currentItems.splice(source.index, 1); currentItems.splice(destination.index, 0, movedItem); // Update order property for all items for consistent sorting const updatedItemsWithOrder = currentItems.map((item, index) => ({ ...item, order: index })); state.actionListItems = updatedItemsWithOrder; persistEditorDataToIndexedDB(state); ``` * **Data Flow Steps:** 1. User interacts with `MarkdownEditor.tsx` or `ActionList.tsx`. 2. Component calls action in `editorSlice`. 3. `editorSlice` updates its state. 4. `editorSlice` (throttled for notepad, immediate for actions) calls `PersistenceService` to save `editorData`. 5. Components re-render from updated `editorSlice` state. * **Key Edge Cases:** * Large Markdown content: Ensure rendering performance (virtualization for preview if needed, post-MVP). * Large number of action list items: List virtualization (post-MVP). * Concurrent edits if ever multi-user (N/A for MVP). * Markdown sanitization misses an XSS vector (keep libraries updated). --- **Feature 8: SFX Feedback** **Goal** To provide crisp, non-intrusive auditory cues for key user actions, reinforcing feedback loops and enhancing the immersive experience. **API relationships** * **Internal Services:** * `SFXManager` (or `sfxService.ts`): A central service/module to load, manage, and play SFX. * `Zustand store (sfxSlice)`: Manages global SFX volume and mute state. * Other Zustand slices/components (e.g., `timerSlice`, `editorSlice` for task check) will call `SFXManager.playSound(soundName)`. * **Browser APIs:** * `Web Audio API` (`AudioContext`, `AudioBufferSourceNode`, `GainNode`): For low-latency playback of buffered audio. * **Asset Loading:** * `import.meta.glob`: For discovering SFX files in `src/assets/sfx/*.mp3` at build time (or they can be explicitly imported/listed). **Architecture overview** * **Diagram Reference:** Various UI components or Zustand slice actions, upon specific events (e.g., timer start, task check), will invoke methods on the `SFXManager`. The `SFXManager` uses Web Audio API for playback and respects volume/mute settings from `sfxSlice`. * **Tech-stack Justification:** * Web Audio API for performance and control over audio playback, essential for SFX. * Zustand for global SFX settings. * **Deployment:** SFX files are small and bundled with the PWA, cached by Service Worker. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `appSettings` (shared store, `sfxSlice` contributes relevant keys) * **Relevant Keys in Record:** ```json { // ... other app settings "sfxVolume": 0.8, // 0.0 to 1.0 "sfxMuted": false } ``` * **Indexes:** N/A. * **Migrations:** Handled by `appSlice` or `PersistenceService`. **API design (`SFXManager` and Zustand `sfxSlice`)** * **`SFXManager` (Service/Module, not a Zustand slice itself):** * `async init(sfxFiles: Record<string, string>)`: Loads all SFX files into `AudioBuffer`s. * `sfxFiles` example: `{'start_session': '/assets/sfx/start_session.mp3', ...}` * `playSound(soundName: string)`: Plays the pre-loaded sound, respecting global volume/mute from `sfxSlice`. * `setVolume(volume: number)`: Internal method called by `sfxSlice` action. * `setMute(muted: boolean)`: Internal method called by `sfxSlice` action. * **Zustand `sfxSlice` Actions & Selectors:** * `setSfxVolume(volume: number)`: Updates state, calls `SFXManager.setVolume`, persists. * `toggleSfxMute()`: Updates state, calls `SFXManager.setMute`, persists. * `loadSfxSettings()` * `selectSfxVolume()` * `selectIsSfxMuted()` * **Auth:** N/A. * **Errors:** Audio file load error during `init`. AudioContext creation/resume issues. * **Rate-limit:** N/A, but avoid triggering too many SFX simultaneously. **Frontend structure** * **Component Hierarchy:** * Settings UI (e.g., in a general settings modal) will have controls for SFX volume/mute, interacting with `sfxSlice`. * `SFXManager` is initialized once, likely in `App.tsx` or a root context. * **State Management (Zustand `sfxSlice`):** * `sfxVolume: number` * `isSfxMuted: boolean` * `isInitialized: boolean` (for `SFXManager`) * **Navigation:** Settings controls within a settings area. **CRUD operations** * N/A. Settings are updated. **UX flow** 1. **App Load:** `SFXManager.init()` is called, pre-loading all SFX files. SFX settings loaded from persistence. 2. **User Action (e.g., clicks "Start Timer"):** * `timerSlice` action calls `SFXManager.playSound('start_session')`. * Sound plays if not muted and volume > 0. 3. **User Changes SFX Volume/Mute in Settings:** * `sfxSlice` action updates state and calls `SFXManager` to apply change immediately. Settings persist. * **Loading States:** Initial loading of SFX files (should be quick, small files). `SFXManager` might expose a `isLoading` state. * **Error States:** If `AudioContext` fails or a sound doesn't play, log silently. Feature should degrade gracefully (no sounds). **Security** * **Auth Flow:** N/A. Browser might suspend `AudioContext` until first user interaction; `SFXManager` should handle `resume()` if needed. * **Roles:** N/A. * **Sanitization:** N/A. * **OWASP Protections:** N/A. **Testing** * **Unit Tests (Vitest):** * `SFXManager` logic: loading sounds (mock fetch/decode), playing sounds (mock Web Audio API), volume/mute application. * `sfxSlice` actions/reducers. * **Integration Tests:** * Verify actions in other slices (e.g., `timerSlice`) correctly trigger `SFXManager.playSound()`. * Settings UI correctly updates `sfxSlice` and `SFXManager`. * Persistence of SFX settings. * **E2E Tests (Playwright/Cypress):** * Difficult to test actual sound output. Can mock `SFXManager.playSound` to verify it's called with correct sound name upon specific user actions. * Test volume/mute controls update application state. * **Performance Tests:** Ensure low latency for SFX playback. Minimal impact from `SFXManager` itself. **Data management** * **Caching:** SFX settings in IndexedDB (`appSettings`). SFX audio files (`.mp3`) cached by PWA Service Worker as they are small critical assets. * **Lifecycle:** Settings persist. Audio buffers held in memory by `SFXManager`. * **Real-time Needs:** Low-latency playback. **Logging & error handling** * **Structured Logs:** * `INFO: SFXManager initialized. Loaded X sounds.` * `INFO: Playing SFX: ${soundName}.` * `INFO: SFX settings updated (Volume: ${volume}, Mute: ${isMuted}).` * `ERROR: Failed to load SFX file ${filePath}: ${error.message}.` * `ERROR: Web Audio API error in SFXManager: ${error.message}.` (e.g., context suspension) * **Alerts:** N/A. * **Recovery:** * If `AudioContext` fails to initialize: SFX are disabled. Log error. * If individual sound fails to load: Log error, that specific sound won't play. * If `AudioContext` is suspended by browser: Attempt `audioContext.resume()` on next user interaction that tries to play a sound. **Detailed requirements** (from input) * Specific sound files list (start_session, pause_session, etc.). * Global mute toggle and volume slider for SFX (distinct from music). * Total SFX asset size ≤ 500 KB. * Reliable playback (Web Audio API). Handle `AudioContext` suspension. **Implementation guide** * **Pseudocode (`SFXManager`):** ```typescript // sfxManager.ts let audioContext = null; let masterGainNode = null; const sfxBuffers = {}; // { soundName: AudioBuffer } let globalVolume = 0.8; let isMuted = false; const sfxFilePaths = { // Populated from import.meta.glob or hardcoded 'start_session': '/assets/sfx/start_session.mp3', // ... other sounds }; async function init() { try { audioContext = new (window.AudioContext || window.webkitAudioContext)(); masterGainNode = audioContext.createGain(); masterGainNode.connect(audioContext.destination); setVolume(globalVolume); // Apply initial/loaded volume const loadPromises = Object.entries(sfxFilePaths).map(async ([name, path]) => { const response = await fetch(path); const arrayBuffer = await response.arrayBuffer(); sfxBuffers[name] = await audioContext.decodeAudioData(arrayBuffer); }); await Promise.all(loadPromises); console.log("SFXManager initialized, sounds loaded."); } catch (e) { console.error("Error initializing SFXManager or loading sounds:", e); audioContext = null; // Disable SFX } } function playSound(soundName) { if (!audioContext || !sfxBuffers[soundName] || isMuted) { if (audioContext && audioContext.state === 'suspended') { audioContext.resume().then(() => playSoundInternal(soundName)); // Try to resume and replay } return; } playSoundInternal(soundName); } function playSoundInternal(soundName) { if (!audioContext || !sfxBuffers[soundName] || isMuted) return; // Double check after resume const source = audioContext.createBufferSource(); source.buffer = sfxBuffers[soundName]; source.connect(masterGainNode); source.start(0); } function setVolume(newVolume) { // Called by sfxSlice globalVolume = newVolume; if (masterGainNode) { masterGainNode.gain.setValueAtTime(isMuted ? 0 : globalVolume, audioContext.currentTime); } } function setMute(muted) { // Called by sfxSlice isMuted = muted; setVolume(globalVolume); // Re-apply volume, which will consider mute state } // Export an object or class instance export default { init, playSound, setVolume, setMute }; ``` * **Data Flow Steps:** 1. `App.tsx` calls `SFXManager.init()` early. Settings loaded into `sfxSlice`, which calls `SFXManager.setVolume/setMute`. 2. User action (e.g., clicks button in `TimerControls.tsx`). 3. Component's event handler or `timerSlice` action calls `SFXManager.playSound('sound_name')`. 4. `SFXManager` plays the sound using Web Audio API, respecting `sfxSlice` volume/mute. * **Key Edge Cases:** * `AudioContext` suspended: Handle resume on interaction. * SFX files missing/corrupted: Log error, sound doesn't play. * Rapid succession of sounds: Web Audio API handles this well generally. * Total SFX asset size: Ensure files are optimized (MP3 compressed, short). --- **Feature 9: PWA Offline Shell** **Goal** To make the application installable and functional offline by caching the UI, core logic (JS, CSS), critical assets (UI images, fonts, SFX), and enabling offline access to features like Timer, Notes, and Posture Tracking (if models are cached). **API relationships** * **Internal Services:** N/A directly. This is build-time configuration and browser capability. * **Browser APIs:** * `Service Worker API`: For intercepting requests, caching, offline support. * `Cache Storage API`: Used by Service Worker to store assets. * `Web App Manifest`: For installability. * **Build Tool:** * `vite-plugin-pwa` (or similar Vite PWA plugin): Manages Service Worker generation and Web App Manifest. **Architecture overview** * **Diagram Reference:** The PWA Service Worker sits between the browser and the network. It intercepts requests from the App Shell. For cached assets, it serves from Cache Storage. For others, it may go to network. * **Tech-stack Justification:** * Service Workers are the standard for PWA offline capabilities. * `vite-plugin-pwa` simplifies SW generation for Vite projects. * **Deployment:** Configuration is part of the build process. Service worker and manifest are deployed with the app. **DB schema (IndexedDB via `PersistenceService`)** * N/A for SW caching itself. IndexedDB is used by features for their data persistence, which SW makes accessible offline. * PWA install prompt logic might use `localStorage` or `IndexedDB` (via `appSlice`) to track prompt display (`hasSeenPwaPrompt`, `installPromptDeferred`). **API design** * **Service Worker Configuration (`vite.config.ts` with `vite-plugin-pwa`):** * `strategies`: `NetworkFirst` or `CacheFirst` for `index.html`. `StaleWhileRevalidate` for static assets (JS, CSS, fonts, UI images, SFX). * `includeAssets`: Specify critical assets to precache (e.g., `/favicon.ico`, `app_icons/*.png`). * `manifest`: Configuration for `manifest.webmanifest` (name, short_name, icons, theme_color, start_url). * Exclusion rules for large assets not to be precached (e.g., `music/**`, `mediapipe_models/**` if large and fetched on demand rather than bundled). * *Clarification*: Posture Tracker models and AI Buddy models need to be considered. If they are small enough and critical for offline, they should be precached. If large, they need a strategy for on-demand caching by the SW or a fallback if offline and not cached. For MVP, MediaPipe Pose models are relatively small and can be precached. Tiny-LLM models (80-100MB) are too large for precache; AI Buddy will need to handle "model not available offline" state if not yet downloaded and cached on first use by the app itself (e.g. in IndexedDB or Cache Storage via a custom fetch and cache logic in `llmService.ts`). * **Custom PWA Install Prompt UI (React component):** * Listens for `beforeinstallprompt` event. * Shows a custom banner/button to trigger `prompt()`. * Tracks prompt display frequency/deferral in `appSlice` state (persisted). **Frontend structure** * **Component Hierarchy:** * Custom PWA install prompt component (e.g., `PWAInstallBanner.tsx`), shown conditionally based on `appSlice` state and `beforeinstallprompt` event. * **State Management (Zustand `appSlice`):** * `canInstallPwa: boolean` * `showPwaInstallPrompt: boolean` (controls custom UI) * `pwaInstallPromptEvent: BeforeInstallPromptEvent | null` * `visitCount: number` (to trigger prompt after N visits) **CRUD operations** * N/A. **UX flow** 1. **First Few Visits:** App works online. Service Worker installed in background, caches assets. 2. **Prompt to Install (e.g., after 2nd visit or significant interaction):** * If `beforeinstallprompt` fired and conditions met (e.g., `appSlice.visitCount >= 2`), custom `PWAInstallBanner.tsx` appears. * User clicks "Install App" on banner -> `pwaInstallPromptEvent.prompt()` called. Browser's native install prompt shows. * User accepts/declines. App tracks outcome via `userChoice` property of event. 3. **Offline Usage:** * User opens app (from URL or installed icon) while offline. * Service Worker serves cached `index.html`, JS, CSS, assets. * App loads quickly from cache. * Features relying on IndexedDB data (Timer, Notes, Goals) work. * Posture Tracker works if MediaPipe models were precached. * Music Player: Metadata/UI works. MP3s might not play if not cached and streaming fails (depends on SW caching strategy for them). MVP: SFX cached, music streamed (may fail offline if not cached). * AI Buddy: If model not cached, shows "offline/model unavailable" message. * Starfield: Falls back to static/simpler version if complex assets not cached. * **Loading States:** Initial SW install is seamless. Subsequent loads from cache are fast. * **Error States:** SW registration failure (log, app works online-only). Cache filling issues. **Security** * **Service Worker Scope:** Restricted to app's origin. * **HTTPS:** Required for Service Workers. * **Cache Integrity:** Handled by browser and SW lifecycle (updates on new SW version). * **OWASP Protections:** Ensure SW doesn't introduce vulnerabilities (e.g., by caching sensitive data incorrectly, though `vite-plugin-pwa` defaults are generally safe). **Testing** * **Unit Tests (Vitest):** * Logic in `appSlice` for PWA install prompt display. * **Integration Tests:** N/A directly for SW, more about build output. * **E2E Tests (Playwright/Cypress):** * Verify Service Worker registration. * Test offline loading: Use browser's offline mode, navigate to app, verify core UI loads and features (Timer, Notes) are usable with pre-existing data. * Test PWA install prompt appearance and dismissal (mock `beforeinstallprompt` or use Chrome dev tools to trigger). * **Manual Testing:** Crucial for PWA features. Test on various devices/browsers. Test update flow when new app version is deployed. * **PWA Checklist Tools:** Lighthouse in Chrome DevTools to audit PWA capabilities. **Data management** * **Caching:** * App Shell (HTML, CSS, JS, fonts, UI images, SFX, small models like MediaPipe Pose) via Service Worker. * Large assets (MP3s, LLM models) explicitly NOT precached by default. LLM models should be fetched on first use of AI Buddy and cached by the app (e.g., in IndexedDB by `llmService.ts` or Cache API). Music MP3s are streamed. * **Lifecycle:** SW updates when new version deployed. Browser manages cache eviction policies. * **Real-time Needs:** N/A for SW itself. **Logging & error handling** * **Structured Logs (Service Worker Console & Main App Console):** * `INFO (SW): Service Worker installing/activated/fetching.` * `INFO (SW): Asset cached: ${assetUrl}.` * `INFO (App): PWA install prompt shown/accepted/dismissed.` * `ERROR (SW): Failed to fetch/cache asset: ${assetUrl}, Error: ${err}.` * `ERROR (App): Service Worker registration failed: ${error.message}.` * **Alerts:** N/A. * **Recovery:** If SW fails, app works as a normal website (online-only). Graceful degradation for features that need cached assets/data when offline. **Detailed requirements** (from input) * Config using `vite-plugin-pwa`. Caching strategies for index, static assets. Web App Manifest. * User prompt to "Install App". * Core functionality (Timer, Posture Tracker (if model cached), Notes, SFX) works offline. Starfield fallback. * Total initial critical JS bundle size ≤ 150 kB (gzipped) - build tool optimization. * Graceful offline fallback for dynamic content (AI Buddy - local LLM avoids this somewhat, but model loading can fail). **Implementation guide** * **`vite.config.ts` (for `vite-plugin-pwa`):** ```typescript // vite.config.ts import { VitePWA } from 'vite-plugin-pwa'; export default { plugins: [ VitePWA({ registerType: 'autoUpdate', // Or 'prompt' for user to reload injectRegister: 'auto', // Or null or 'script' workbox: { globPatterns: ['**/*.{js,css,html,ico,png,svg,json,woff2,woff,ttf,mp3,wasm}'], // mp3 for sfx, wasm for mediapipe // Exclude large music files and LLM models from precache globIgnores: [ 'assets/music/**/*', // Music files are streamed, not precached 'assets/llm_models/**/*' // LLM models are too large, fetched on demand ], maximumFileSizeToCacheInBytes: 5 * 1024 * 1024, // e.g. 5MB for individual files }, manifest: { name: 'DeepWork Spacestation', short_name: 'DW Spacestation', description: 'Immersive productivity dashboard for deep work.', theme_color: '#1A202C', // Example dark theme color background_color: '#000000', display: 'standalone', scope: '/', start_url: '/', icons: [ /* array of icon objects */ { src: '/app_icons/icon-192x192.png', sizes: '192x192', type: 'image/png' } ], }, }) ] } ``` * **PWA Install Prompt Logic (in `appSlice` and a React component):** ```typescript // appSlice.ts state = { pwaInstallPromptEvent: null, showCustomPwaPrompt: false, visitCount: 0, // increment on app load, persist } // In App.tsx or a root component's useEffect useEffect(() => { const handler = (e) => { e.preventDefault(); // Prevent mini-infobar store.getState().setPwaInstallPromptEvent(e); // Save event to Zustand if (store.getState().visitCount >= 2) { // Example condition store.getState().setShowCustomPwaPrompt(true); } }; window.addEventListener('beforeinstallprompt', handler); return () => window.removeEventListener('beforeinstallprompt', handler); }, []); // PWAInstallBanner.tsx function PWAInstallBanner() { const { pwaInstallPromptEvent, showCustomPwaPrompt, hidePrompt, markInstalled } = useAppStore(...); if (!showCustomPwaPrompt || !pwaInstallPromptEvent) return null; const handleInstallClick = async () => { pwaInstallPromptEvent.prompt(); const { outcome } = await pwaInstallPromptEvent.userChoice; if (outcome === 'accepted') markInstalled(); // Update state, hide prompt permanently hidePrompt(); // Hide custom prompt }; // return <Banner ... onClick={handleInstallClick} onDismiss={hidePrompt} /> } ``` * **Data Flow Steps:** 1. Build process generates Service Worker and Manifest. 2. Browser loads app, registers SW. SW caches assets per config. 3. `beforeinstallprompt` event fires, saved by `appSlice`. 4. Custom prompt UI shown based on `appSlice` logic. 5. User interacts with prompt, triggers native install. 6. On subsequent offline visits, SW serves from cache. * **Key Edge Cases:** * SW update lifecycle: How new versions are handled (e.g., `autoUpdate` vs. `prompt` for reload). * Cache storage limits: Browser may clear cache. * Different browser PWA support levels. * Large assets: Ensure they are not precached if not intended. LLM model caching strategy needs to be robust (fetch on demand, cache in IndexedDB or Cache API, handle offline if not yet cached). --- **Feature 10: AI Buddy Chat** **Goal** To provide a side-docked chat interface for users to interact with a locally running "Tiny-LLM" for motivation, task assistance (e.g., milestone ideas), and optional "story mode" prompts, enhancing engagement and focus. **API relationships** * **Internal Services:** * `Zustand store (aiBuddySlice)`: Manages chat history, model loading state, current model size preference, user input. * `ModelInteractionService.ts` (or `llmService.ts`): Handles loading Transformers.js, selected LLM model (DistilGPT-2 or Phi-2), and running inference. This service might use a Web Worker for inference if needed. * `PersistenceService (IndexedDB)`: Saves chat history and model size preference. * **Browser APIs:** * `Web Worker` (optional): For offloading model inference if it blocks the main thread. Transformers.js WASM backend is often efficient but for larger models or smoother UX, worker is good. * `IndexedDB`: For storing model files if downloaded on-demand by the app, and chat history. * **Libraries:** * `Transformers.js`: To run local LLMs (DistilGPT-2, Phi-2 quantized). **Architecture overview** * **Diagram Reference:** `AIBuddyChat.tsx` UI interacts with `aiBuddySlice`. Actions in `aiBuddySlice` call `ModelInteractionService` to process prompts. `ModelInteractionService` uses Transformers.js (possibly in a worker) for inference. Chat history and settings are persisted via `PersistenceService`. * **Tech-stack Justification:** * React for UI. Zustand for state. * Transformers.js for client-side LLM, aligning with offline-first and no API key requirements. * IndexedDB for chat history and model caching. * **Deployment:** Part of PWA. Transformers.js library bundled. LLM models (.bin, .json, .onnx files) are larger assets. * **Model Hosting Strategy:** Models (e.g., Phi-2 quantized ~100MB) are too large for PWA precache. They should be: 1. Placed in `public/assets/llm_models/` directory. 2. Fetched on first use of AI Buddy (or user selection of model size) by `ModelInteractionService`. 3. Stored in IndexedDB (e.g., as ArrayBuffer) or Cache API by `ModelInteractionService` for offline access. 4. Clear indication of download progress to user. **DB schema (IndexedDB via `PersistenceService`)** * **Object Store:** `aiChatHistory` * **KeyPath:** `id` (auto-incrementing or UUID for each message). * **Structure Example:** ```json { "id": 1, // or "uuid-msg-1" "sender": "user", // "user" | "ai" "text": "Give me three study milestone ideas for the next 25 min.", "timestamp": 1678890000000 } ``` * **Indexes:** `timestamp` (for fetching recent messages, purging old ones). * **Object Store:** `appSettings` (shared store) * **Relevant Keys in Record:** ```json { // ... other app settings "aiBuddyModelSize": "small" // "small" (DistilGPT-2) | "normal" (Phi-2) } ``` * **Object Store:** `cachedModels` (managed by `ModelInteractionService`) * **KeyPath:** `modelName` (e.g., "distilgpt2", "phi-2-quantized") * **Structure Example:** ```json { "modelName": "distilgpt2", "files": { // Key-value store of model files (config.json, model.bin, etc.) "config.json": ArrayBuffer, // Storing as ArrayBuffer "pytorch_model.bin": ArrayBuffer }, "downloadedTimestamp": 1678890000000 } ``` **API design (`aiBuddySlice`, `ModelInteractionService`)** * **`ModelInteractionService`:** * `async init(modelPathPrefix: string, modelName: string, onProgress: (progress) => void)`: Loads model files (from network or `cachedModels` DB). `onProgress` for download/load status. * `async generateResponse(prompt: string, onToken: (token: string) => void): Promise<string>`: Sends prompt to loaded model. `onToken` for streaming response. Returns full response. * `isModelLoaded(modelName: string): boolean` * `getLoadedModelName(): string | null` * **Zustand `aiBuddySlice` Actions & Selectors:** * `sendMessage(text: string)`: Adds user message to history, calls `ModelInteractionService.generateResponse`, adds AI response (streamed) to history. * `setModelSize(size: 'small' | 'normal')`: Updates preference, triggers model load via `ModelInteractionService` if different. * `loadChatHistory()`: Loads recent messages from IndexedDB. * `clearOldChatHistory()`: Purges messages older than 7 days or beyond 500 message limit. * `_handleTokenStream(token: string)`: Appends token to last AI message in history. * **Selectors (examples):** * `selectChatMessages(): ChatMessage[]` * `selectIsModelLoading(): boolean` * `selectCurrentModelSize(): string` * `selectModelLoadProgress(): number` * **Auth:** N/A. * **Errors:** Model load/download failure. Inference error. IndexedDB errors. * **Rate-limit:** N/A for local model, but UI should prevent spamming if generation is slow. **Frontend structure** * **Component Hierarchy:** * `AIBuddyChat.tsx` (Side-docked panel, message list, input field, model size toggle/indicator, loading/progress indicator) * `ChatMessage.tsx` (Renders individual user/AI messages, handles per-token fade-in for AI) * **State Management (Zustand `aiBuddySlice`):** * `chatMessages: { id, sender, text, timestamp }[]` * `isLoadingModel: boolean` * `modelLoadProgress: number` // 0-1 for download/initialization * `isGeneratingResponse: boolean` * `currentModelSize: 'small' | 'normal'` * **Navigation:** Chat panel can be part of a collapsible side dock. **CRUD operations** * **Chat Messages:** * Create: User sends message, AI responds. Added to `chatMessages` array and IndexedDB. * Read: Displayed in chat UI. * Delete: Old messages purged automatically. No manual delete for MVP. * **Validation:** User input length limits? (Soft). * **Pagination:** Virtual scrolling for long chat history. For MVP, load N recent messages. **UX flow** 1. **Initial State / Model Not Loaded:** Chat panel shows "Loading AI Buddy..." or "Select model size to start." Model size toggle available. 2. **User Selects Model Size (or on first open with default):** * `ModelInteractionService.init()` called. * If model not in `cachedModels` DB, download starts from `public/assets/llm_models/`. Progress bar shown. * Once downloaded/loaded from cache, model initialized by Transformers.js. * Chat input becomes active. "AI Buddy is ready." 3. **User Types Prompt and Sends:** * Message added to UI immediately. `isGeneratingResponse = true`. * Prompt sent to `ModelInteractionService`. * AI response streams in: `ChatMessage.tsx` updates with new tokens, per-token fade-in effect. 4. **Chat History:** Scrollable. Persists across sessions. Old messages purged per rules. * **Loading States:** Model download progress, model initialization spinner, "AI thinking..." indicator while generating. * **Error States:** * "Failed to download/load AI model. Please check internet connection or try again." * "AI Buddy encountered an error. Please try a different prompt." * "Chat history unavailable." **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** User input is passed to LLM as text. AI output is text. If this text is ever rendered as HTML directly (outside of simple text nodes/attributes), it would need sanitization, but for chat bubbles displaying text, it's generally fine. * **OWASP Protections:** N/A directly. * **Model Safety:** Local LLMs can still generate undesirable content. This is an inherent risk. For MVP, it's accepted given "Tiny-LLM" capabilities. No server-side filtering. **Testing** * **Unit Tests (Vitest):** * `aiBuddySlice` actions/reducers: message handling, history management, state updates. * `ModelInteractionService` logic: model loading (mock Transformers.js), prompt processing (mock inference). * Chat history purging logic. * **Integration Tests:** * `AIBuddyChat.tsx` component interaction with `aiBuddySlice` and `ModelInteractionService`. * Persistence of chat history and settings. * Model caching logic (mock fetches and IndexedDB for `cachedModels`). * **E2E Tests (Playwright/Cypress):** * Test model selection and loading indication. * User sends a prompt, verify AI response appears (mocked LLM response for predictability). * Test chat history persistence and scrolling. * Test per-token fade-in effect (visual check or assert intermediate states). * **Performance Tests:** * Model load time (target 1-2s for selected model on average laptop, after download). * Token generation speed (Time To First Token, Tokens Per Second). * UI responsiveness during inference (if not using worker, check for jank). **Data management** * **Caching:** * Chat history in `aiChatHistory` (IndexedDB), purged periodically. * User's model size preference in `appSettings` (IndexedDB). * Downloaded LLM model files in `cachedModels` (IndexedDB or Cache API). * **Lifecycle:** Chat history accumulates, old messages purged. Model files cached until user clears site data or app logic provides option to clear. * **Real-time Needs:** AI response streams token by token. **Logging & error handling** * **Structured Logs:** * `INFO: AI Buddy model ${modelName} loading started/completed.` * `INFO: AI Buddy model download progress: ${progress}%.` * `INFO: User prompt: "${prompt}", AI response started.` * `INFO: Chat history purged: X messages removed.` * `ERROR: AI Model download failed for ${modelName}: ${error.message}.` * `ERROR: AI Model inference error: ${error.message}.` * `ERROR: Failed to save/load chat history: ${error.message}.` * **Alerts:** N/A. * **Recovery:** * Model load failure: Inform user, allow retry or selection of different model. AI Buddy disabled until model loads. * Inference error: Show error message in chat, allow user to try new prompt. * History load failure: Start with empty chat. **Detailed requirements** (from input) * Chat UI, input field. Story Mode / Task Assistance prompts. * Model Size Toggle (Normal/Small). Response streaming with per-token fade-in. * Transformers.js with local DistilGPT-2 or Phi-2 (WASM). * IndexedDB for chat history (purge after 500 msgs / 7 days). * Model load time target (1-2s). Client-side, offline-first. * Clear indication of model loading/processing. **Implementation guide** * **Pseudocode (`ModelInteractionService.ts` with Transformers.js):** ```typescript // ModelInteractionService.ts import { AutoModelForCausalLM, AutoTokenizer, pipeline } from '@xenova/transformers'; let generator = null; // Transformers.js pipeline let currentModelName = null; const MODEL_BASE_PATH = '/assets/llm_models/'; // Assuming models are in public async function init(modelName, onProgressCallback) { if (currentModelName === modelName && generator) return generator; // Already loaded // TODO: Implement model caching in IndexedDB ('cachedModels' store) // 1. Check if modelName files are in IndexedDB. // 2. If yes, load ArrayBuffers from IDB. // 3. If no, fetch from network (MODEL_BASE_PATH + modelName + '/file'), show progress, store in IDB. // For MVP, direct load from path, assuming network or SW cache. // Transformers.js handles fetching from path if not providing buffers. // Progress callback for Transformers.js own loading: const loadingProgress = (data) => { if (data.status === 'progress') { onProgressCallback(data.progress); // Progress 0-100 } }; try { // For Phi-2 or other specific models, might need AutoModelForCausalLM.from_pretrained directly // The 'text-generation' pipeline is a high-level abstraction. // Using model name like 'Xenova/distilgpt2' or 'Xenova/phi-1_5-quantized' // Or, if using local files: provide path to directory containing config.json, model.onnx, etc. // For local files (after fetching/caching them): // const model = await AutoModelForCausalLM.from_pretrained(pathToCachedModelDir); // const tokenizer = await AutoTokenizer.from_pretrained(pathToCachedModelDir); // generator = { model, tokenizer }; // Simplified, actual pipeline setup is more complex generator = await pipeline('text-generation', modelName, { progress_callback: loadingProgress, // For quantized models, specific config might be needed. // It's assumed modelName is a path Transformers.js can resolve to fetch model files. }); currentModelName = modelName; onProgressCallback(100); // Mark as complete return generator; } catch (e) { console.error(`Failed to load model ${modelName}:`, e); generator = null; currentModelName = null; throw e; } } async function generateResponse(prompt, onTokenCallback) { if (!generator) throw new Error("Model not loaded."); const stream = await generator(prompt, { max_new_tokens: 100, // Adjust as needed // callback_function: (beams) => { // For streaming tokens // const generatedToken = generator.tokenizer.decode(beams[0].output_token_ids.slice(-1)[0]); // onTokenCallback(generatedToken); // } // Simpler way if pipeline supports it or using lower-level generate: }); // Transformers.js v2 pipeline text-generation returns full text. // For token streaming, you need to use model.generate() and decode tokens iteratively. // This is a simplified representation. Actual streaming is more involved. // Example of iterative generation for streaming: // let input_ids = tokenizer(prompt).input_ids; // for (let i = 0; i < max_new_tokens; ++i) { // let output = await model({ input_ids }); // let next_token_id = output.logits[0].argmax(-1); // Simplified // input_ids = [...input_ids, next_token_id]; // let tokenText = tokenizer.decode([next_token_id]); // onTokenCallback(tokenText); // if (next_token_id === tokenizer.eos_token_id) break; // } // const fullResponse = tokenizer.decode(input_ids); // For MVP, if direct streaming from pipeline is hard, generate full response and then "stream" it to UI. // But true LLM streaming is better. Let's assume pipeline gives full text for now for simplicity, // and streaming to UI is a visual effect post-generation. // Per prompt: "Responses streamed to the UI with a per-token fade-in effect" // This implies true token-by-token generation if possible. const fullResponse = Array.isArray(stream) ? stream[0].generated_text : stream.generated_text; // Simulate streaming for UI if model doesn't stream easily: const words = fullResponse.replace(prompt, '').trim().split(/(\s+)/); // Split by words and spaces for (const word of words) { onTokenCallback(word); await new Promise(resolve => setTimeout(resolve, 25)); // Simulate token delay } return fullResponse.replace(prompt, '').trim(); } ``` * **Data Flow Steps:** 1. User selects model size in `AIBuddyChat.tsx` -> `aiBuddySlice.setModelSize`. 2. `aiBuddySlice` calls `ModelInteractionService.init()` with chosen model. 3. `ModelInteractionService` loads model (fetches from network/public, caches to `cachedModels` DB if first time, reports progress to `aiBuddySlice`). 4. User types prompt -> `aiBuddySlice.sendMessage`. 5. `aiBuddySlice` adds user message to history, calls `ModelInteractionService.generateResponse`. 6. `ModelInteractionService` gets response from LLM (ideally token by token). Each token callback updates `aiBuddySlice`. 7. `aiBuddySlice` appends tokens to the current AI message in history. UI re-renders message. 8. Chat history saved to `aiChatHistory` DB. * **Key Edge Cases:** * User switches model while one is loading/generating (cancel current, start new). * Network error during model download (handle resume/retry if possible). * IndexedDB quota issues for model caching or chat history. * Browser tab in background (WASM execution might be throttled). --- **Feature 11: Focus Booster (Huberman Gaze-Lock)** **Goal** To provide a full-screen, 30-second gaze-lock exercise with an animated starfield and a central growing dot, designed to prime visual attention and help users refocus. **API relationships** * **Internal Services:** * `Zustand store (focusBoosterSlice)`: Manages booster state (idle, active, countdown, current phase). * `Zustand store (starfieldSlice)`: `focusBoosterSlice` may request a high-speed/specific mode from `starfieldSlice` or use a dedicated canvas instance. * `Zustand store (appSlice)`: Reads global performance mode to adjust booster visuals if necessary. * `SFXManager`: For "whoosh" start, ambient bed, and complete SFX. * **Browser APIs:** * `Canvas API` or `WebGL API`: For the starfield background and animated dot/ring. Reuses existing Starfield component or a dedicated one. * `requestAnimationFrame`: For smooth animations of dot/ring. * `Fullscreen API` (optional): To make it truly full-screen, but can also be a max-sized div. **Architecture overview** * **Diagram Reference:** `BoosterIcon.tsx` triggers state change in `focusBoosterSlice`. `FocusBooster.tsx` component renders the full-screen experience based on `focusBoosterSlice` state, potentially using `StarfieldCanvas.tsx` with modified parameters. SFX triggered via `SFXManager`. * **Tech-stack Justification:** * React for UI. Zustand for state. * Canvas/WebGL for visuals. CSS animations for dot/ring if simple enough, or Canvas for precision. * **Deployment:** Part of PWA. Assets (SFX) bundled. **DB schema (IndexedDB via `PersistenceService`)** * N/A for this feature directly. Settings for performance that affect it are in `appSettings`. **API design (Zustand `focusBoosterSlice` actions & selectors)** * **Actions (examples):** * `startBooster()`: Sets state to 'active', fades out main UI, shows booster UI, starts SFX/animation timer. * `_updateBoosterAnimation(progress: number)`: Updates dot size/ring progress. * `completeBooster()`: Shows "FOCUS PRIMED", plays complete SFX, sets state for auto-exit or close button. * `exitBooster()`: Fades booster UI out, restores main UI, resets state to 'idle'. * `_tickTimer()`: Internal action for the 30s countdown. * **Selectors (examples):** * `selectBoosterStatus(): 'idle' | 'starting' | 'active' | 'finishing' | 'done'` * `selectBoosterProgress(): number` // 0-1 for 30s duration * `selectDotSize(): number` * **Auth:** N/A. * **Errors:** Animation glitches. SFX load/play errors. * **Rate-limit:** N/A. **Frontend structure** * **Component Hierarchy:** * `BoosterIcon.tsx` (Docked button, hover effects) * `FocusBooster.tsx` (Full-viewport overlay component, manages internal animation states/phases, displays dot, ring, text prompts, exit button. Uses `StarfieldCanvas.tsx` or its own canvas.) * **State Management (Zustand `focusBoosterSlice`):** * `status: 'idle' | 'starting' | 'active' | 'finishing' | 'done'` * `startTime: number | null` * `progress: number` // 0.0 to 1.0 * (Derived states for dot size, ring animation based on progress) * **Navigation:** Feature is an overlay, not a separate route. **CRUD operations** * N/A. **UX flow** (as per prompt Screen 1 / Screen 2 descriptions) 1. **Screen 1 - Idle Dock Button:** `BoosterIcon.tsx` visible, shows tooltip on hover. 2. **Button Hover:** Icon pulses. 3. **Button Click -> Launch:** * SFX: `whoosh_start.mp3`. Button haptic shake. * Main UI fades to black/dark over 200-300ms. `FocusBooster.tsx` becomes visible. * Starfield layer visible, possibly at increased speed (e.g., 8x). 4. **Screen 2 - Booster Mode (Full Screen):** * Canvas covers viewport. Central bright dot (16px) inside guiding ring (48px). * Exit button (X icon) in corner. * Text "Fixate on the star" fades in/out. * Ambient SFX (`ambient_booster_bed.mp3`) plays low. * Over 30 seconds: * Dot radius interpolates (16px -> 48px). * Ring stroke animates (0% -> 100%) as progress. * On completion (30s): * SFX: `booster_complete.mp3`. Visual flourish (bloom). * Text "FOCUS PRIMED" appears. * "Close" button appears, or auto-exits after 2-3s to main UI. 5. **Exit:** Clicking "X", "Close", or Escape key calls `exitBooster()`, returns to main UI. * **Loading States:** Minimal. SFX should be preloaded. Starfield already running. * **Error States:** Visual glitches, SFX failure (log silently). **Security** * **Auth Flow:** N/A. * **Roles:** N/A. * **Sanitization:** N/A. * **OWASP Protections:** N/A. **Testing** * **Unit Tests (Vitest):** * `focusBoosterSlice` actions/reducers: state transitions, timer logic, progress calculation. * Animation interpolation logic for dot/ring. * **Integration Tests:** * `BoosterIcon.tsx` correctly triggers `focusBoosterSlice.startBooster()`. * `FocusBooster.tsx` component correctly renders based on slice state. * SFX calls are made at correct times. * Interaction with `starfieldSlice` or `StarfieldCanvas` parameters. * **E2E Tests (Playwright/Cypress):** * User clicks icon, booster starts. Verify UI elements (dot, ring, text prompts) appear/animate as expected (visual snapshots or DOM checks). * Verify timer completion and "FOCUS PRIMED" state. * Test exit conditions (X button, Escape key, auto-exit). * **Performance Tests:** * Maintain 60 FPS for animations on mid-range GPUs. * Ensure performance mode settings from `appSlice` are respected (Eco mode: simplified/disabled booster). **Data management** * **Caching:** SFX cached. No specific data persisted for this feature itself. * **Lifecycle:** State is transient for each booster session. * **Real-time Needs:** Smooth 60 FPS animations. **Logging & error handling** * **Structured Logs:** * `INFO: Focus Booster started/completed/exited.` * `WARN: Focus Booster animation performance issue detected.` (If measurable) * `ERROR: SFX failed for Focus Booster: ${sfxName}, ${error.message}.` * **Alerts:** N/A. * **Recovery:** If critical animation fails, try to exit booster gracefully. If SFX fails, proceed without. **Detailed requirements** (from input) * Detailed screen flow (Idle Dock, Booster Mode). * Specific animations: dot growth, ring progress, text fades, UI fade in/out. * Specific SFX. * 60 FPS target, use performant animations (transform, opacity, canvas). * Escape key / exit button. * Respects Performance modes from Settings (Eco might disable or simplify). **Implementation guide** * **Pseudocode (Animation logic in `FocusBooster.tsx` or `useFocusBoosterAnimation` hook):** ```typescript // FocusBooster.tsx (simplified animation part) // State from focusBoosterSlice: status, progress (0-1) // Inside render or useEffect driving canvas draw: const DURATION_MS = 30000; const initialDotRadius = 8; // 16px diameter const finalDotRadius = 24; // 48px diameter currentDotRadius = initialDotRadius + (finalDotRadius - initialDotRadius) * progress; // For ring (SVG or Canvas arc): // strokeDashoffset = circumference * (1 - progress); // Text visibility based on progress / status: // if progress < 0.1 && status === 'active': show "Fixate on the star" // if status === 'done': show "FOCUS PRIMED" // Using requestAnimationFrame for canvas drawing if not CSS animations: function drawBoosterFrame(ctx, canvasWidth, canvasHeight, currentProgress) { // Clear canvas // Draw Starfield (passed from main starfield or own instance) // Calculate dotRadius from currentProgress // Draw central dot // Draw progress ring // Draw text overlays based on currentProgress/status } // In focusBoosterSlice, using a timer: function _tickTimer(): if state.status !== 'active': return; elapsed = Date.now() - state.startTime; progress = Math.min(elapsed / DURATION_MS, 1.0); state.progress = progress; if (progress >= 1.0) { completeBooster(); // Changes status to 'finishing' or 'done' } else { // Schedule next tick (e.g. via setTimeout calling _tickTimer again) } ``` * **Data Flow Steps:** 1. User clicks `BoosterIcon.tsx` -> `focusBoosterSlice.startBooster()`. 2. `focusBoosterSlice` updates status, records `startTime`. Main UI fades. 3. `FocusBooster.tsx` component (listening to slice) renders, starts its 30s timer loop (which updates `progress` in slice). 4. `FocusBooster.tsx` uses `progress` to drive animations of dot, ring, and text. Plays SFX. 5. On 30s completion, `focusBoosterSlice.completeBooster()` is called. 6. `FocusBooster.tsx` shows final state, then calls `exitBooster()` after delay or on user action. * **Key Edge Cases:** * User tries to activate booster while already active (should be no-op or restart). * Performance mode "Eco": Booster disabled or uses static image with text. * Rapidly exiting/re-entering (ensure proper cleanup of timers/animations). ```

Från <https://aistudio.google.com/prompts/13Z30I3YDdRgXTjPzEWrw82jfyhvNCgic> 

